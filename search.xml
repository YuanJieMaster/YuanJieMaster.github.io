<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【7天用Go从零实现】Web框架Gee教程(1)</title>
      <link href="/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="7天用Go从零实现Web框架Gee教程（2）"><a href="#7天用Go从零实现Web框架Gee教程（2）" class="headerlink" title="7天用Go从零实现Web框架Gee教程（2）"></a>7天用Go从零实现Web框架Gee教程（2）</h1><p>本文参考：<a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html</a></p><p>好的，让我们继续往下看</p><h2 id="Day2-上下文"><a href="#Day2-上下文" class="headerlink" title="Day2 上下文"></a>Day2 上下文</h2><p>先看看文件结构吧</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">│  <span class="keyword">go</span>.mod</span><br><span class="line">│  main.<span class="keyword">go</span></span><br><span class="line">│</span><br><span class="line">└─gee</span><br><span class="line">        context.<span class="keyword">go</span></span><br><span class="line">        gee.<span class="keyword">go</span></span><br><span class="line">        <span class="keyword">go</span>.mod</span><br><span class="line">        router.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>这里是对gee框架进一步拆解模块化，分为context，gee，router，重点看看context，就是其实就是将Request和Response进行了封装，顶多将常用的Path、Method、StatusCode拎出来了而已， 噢，还有内部的方法，写响应的String、JSON、Data、HTML各种格式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// origin objects</span></span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"><span class="comment">// request info</span></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line"><span class="comment">// response info</span></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router是关于路由映射的一些方法（废话x，而gee中只是对这些方法进行简单的调用，一开始还觉得有点多此一举的，不过这是为了框架的清晰划分</p><h2 id="Day3-前缀树路由"><a href="#Day3-前缀树路由" class="headerlink" title="Day3 前缀树路由"></a>Day3 前缀树路由</h2><p>老规矩，先看看文件结构</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">│  <span class="keyword">go</span>.mod</span><br><span class="line">│  main.<span class="keyword">go</span></span><br><span class="line">│</span><br><span class="line">└─gee</span><br><span class="line">        context.<span class="keyword">go</span></span><br><span class="line">        gee.<span class="keyword">go</span></span><br><span class="line">        <span class="keyword">go</span>.mod</span><br><span class="line">        router.<span class="keyword">go</span></span><br><span class="line">        router_test.<span class="keyword">go</span></span><br><span class="line">        trie.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺带一提，tree /f查看文件结构</span></span><br></pre></td></tr></table></figure><p>在之前的基础上增加了trie文件和router_test文件</p><p>从文章标题就知道路由的增强是重头戏，这里通过trie树的数据结构对路由进行了加强，实现了动态路由，trie文件就是trie树算法的文件，还有就是router_test这个文件，出现了单元测试的概念，有所耳闻，当初看到的时候很兴奋，看了看是在文件中设置了一些预设，以便进行测试，还有就是router_test文件的图标都是不一样的，看来在Goland看来router_test文件是比较独特的，对于单元测试这一块就放到下一次再写好了，因为现在我也没搞懂，停下来写博客只是因为思路比较混乱，现在好多了（滑稽），前面就是未知领域了，等我先研究研究</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【7天用Go从零实现】Web框架Gee教程(1)</title>
      <link href="/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="7天用Go从零实现Web框架Gee教程-1"><a href="#7天用Go从零实现Web框架Gee教程-1" class="headerlink" title="7天用Go从零实现Web框架Gee教程(1)"></a>7天用Go从零实现Web框架Gee教程(1)</h1><p>本文参考：<a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html</a></p><p>研究这个教程的时候，我刚刚开始学习用Go，觉得单纯看语法学习效率较低，而且容易遗忘，所以就打算边看边学，顺便学习Web框架相关的知识，之前用过爬虫，但还只是浅尝辄止，稀里糊涂，我想学习Web框架也有助于对爬虫的理解。</p><p>对于初步使用Go语言搭建Web应用的人来说，Gin框架无疑是最常见的，我也不例外，之前也用Gin写了一个简单的TODOList， 而Gee框架是一个简化的类Gin框架，适合帮助初学者理解Web框架。</p><p>写这篇博客的时候我已经看到了Day3，到Day3的时候项目已经逐渐变得稍微复杂起来，而且出现了单测这个之前有所耳闻的概念，脑子里有些混乱了，于是打算停下来复盘一下，顺便写篇博客。</p><h2 id="Day0-序言"><a href="#Day0-序言" class="headerlink" title="Day0  序言"></a>Day0  序言</h2><p>框架有简化开发的作用，避免了不必要的繁复操作，同时框架提供了很多额外的功能，像是动态路由、中间件等等</p><h2 id="Day1-HTTP基础"><a href="#Day1-HTTP基础" class="headerlink" title="Day1 HTTP基础"></a>Day1 HTTP基础</h2><p>这篇包括了三个Web应用版本，由最基础逐渐复杂起来（虽然整个教程就是这样一个常见的“合理的”难度梯度）</p><h3 id="base1"><a href="#base1" class="headerlink" title="base1"></a>base1</h3><p>这里主要就是要了解net&#x2F;http标准库中的HandleFunc和ListenAndServe两个函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// day1-http-base/base1/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes r.URL.Path</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes r.URL.Header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenAndServe这个函数是比较简单的，看看ListenAndServe的源码好了</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建一个 TCP 监听器  </span></span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 确保在退出时关闭监听器  </span></span><br><span class="line">    <span class="keyword">defer</span> listener.Close()  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有提供处理器，使用 DefaultServeMux  </span></span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;  </span><br><span class="line">        handler = DefaultServeMux  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入接受连接的循环  </span></span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        <span class="comment">// 接受连接  </span></span><br><span class="line">        conn, err := listener.Accept()  </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">            <span class="comment">// 处理错误  </span></span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个连接启用一个新的 goroutine  </span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">            <span class="keyword">defer</span> conn.Close() <span class="comment">// 确保连接在处理完后关闭  </span></span><br><span class="line">            <span class="comment">// 处理请求的逻辑  </span></span><br><span class="line">            <span class="comment">// 这包括读请求、调用处理器、写回响应等  </span></span><br><span class="line">            handler.ServeHTTP(conn, ...)  </span><br><span class="line">        &#125;()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数是监听的端口号，第二个参数则是处理器Handler，Handler当然也是http库中定义的接口，需要实现ServeHTTP方法，按我的理解就是ListenAndServe是用来监听指定端口并且指定对应的处理器，（我的博客里会有很多自己的臆测，请自行判断，也欢迎大佬斧正）如果第二个参数是nil则会调用默认的，去看HandleFunc函数</p><p>那接下来就看一看HandleFunc函数，先上源码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http  </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the URL path prefix.  </span></span><br><span class="line"><span class="comment">// The handler will be called for all requests whose URL path starts with  </span></span><br><span class="line"><span class="comment">// the given prefix.  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;  </span><br><span class="line">    <span class="comment">// Wrap the handler function to convert it to the Handler interface  </span></span><br><span class="line">    Handle(pattern, HandlerFunc(handler))  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc is an adapter to allow the use of ordinary functions as HTTP handlers.  </span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls h(w, r).  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;  </span><br><span class="line">    h(w, r)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle registers the handler h for the given pattern in the DefaultServeMux.  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="type">string</span>, handler Handler)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// Check for nil handler  </span></span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Register the handler in the DefaultServeMux  </span></span><br><span class="line">    DefaultServeMux.Handle(pattern, handler)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler is an interface that wraps the ServeHTTP method.  </span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;  </span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>HandleFunc函数就是将URL路由映射到对应的处理方法，处理方法要实现Handler（处理者）接口（这也是很自然的吧）</p><p>总结一下，ListenAndServe监听，HandleFunc映射路由，Handler处理。</p><h3 id="base2"><a href="#base2" class="headerlink" title="base2"></a>base2</h3><p>上面的base1只是最基本最基本的实现方法，base2主要是要创建一个实例，并且实现Handler接口，放在ListenAndServe函数中的第二个参数的位置上</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// day1-http-base/base2/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine is the uni handler for all requests</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/hello&quot;</span>:</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine := <span class="built_in">new</span>(Engine)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, engine))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义Engine结构体，实现ServeHTTP方法，实现的方式是完全自定义的，也就是说，这里有着更大的开发空间，相当于重构了HandleFunc函数。我们利用engine拦截所有的HTTP请求，然后自定义相应方式，包括路由的对应关系也是，对于之前的HandleFunc函数，只能实现具体的路由与处理方法的一一映射，也就是静态路由，而自定义的话就可以实现动态路由，动态路由简单来说就是实现模糊匹配，一个通式路由可以匹配一系列路由。</p><h3 id="base3"><a href="#base3" class="headerlink" title="base3"></a>base3</h3><p>到base3就初具框架雏形了，base3将构建的东西封装起来，封成一个独立的包，开发者只需调用包中的函数简化开发</p><p>由于代码有点开始多了，在放在这里会比较占篇幅，我不放在这了，想看源码可以移步至教程原文，链接在开头</p><p>以下是基本框架</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gee/</span><br><span class="line">  |--gee.<span class="keyword">go</span></span><br><span class="line">  |--<span class="keyword">go</span>.mod</span><br><span class="line">main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span>.mod</span><br></pre></td></tr></table></figure><p>Engine中多了一个路由匹配表router的东西，顾名思义，将路由映射到处理方法，这与之前的有什么不同呢？这里增加了GET、POST的概念，也就是说，路由并不是原始的url，而是增加了方法method（大概是GET-&#x2F;hello这样的感觉），这将请求进行了分类，扩大了请求的概念范围，同时可以实现在同一个页面发送不同的请求的效果</p><p>总结一下，Engine结构体，内部有路由匹配表，增强了Handler的功能</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客日志（2）</title>
      <link href="/2024/09/18/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89/"/>
      <url>/2024/09/18/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客的报错和解决"><a href="#本博客的报错和解决" class="headerlink" title="本博客的报错和解决"></a>本博客的报错和解决</h1><p>在使用博客的过程中， 也出现了不少问题，虽然在日志（1）中也写了两个报错，而在这里就写写出现的报错我感觉可以单独写一篇，在写这篇博客的时候我可能还没有解决这些错误，会有我的探索过程</p><p>目前出现的最大的问题就是在博客本地仓库修改过之后，进行提交会报错，这种错误我之前也遇到过，一般都是通过推倒重来，重新搭建博客解决的，但这终究不是长久之计，于是想着深入了解报错的原因</p><p>首先我打算查看一下本地仓库和远程仓库的提交记录，看两者出了什么差错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看本地提交记录</span><br><span class="line">git log</span><br><span class="line">//查看远程仓库提交记录</span><br><span class="line">git log origin/main</span><br></pre></td></tr></table></figure><p>看了两边的提交记录之后确实差得很大，甚至就没有重合的部分，可能是我之前由于某种原因清除了本地的原因，既然完全不同，那还是重建仓库好了，这边也是，由于.deploy_git文件夹是用于存储文件以及git提交的文件夹，我本来想过删除本地的提交记录，但是好像不可行，于是我就干脆删除该文件夹，重新放入初始的.deploy_git文件夹，使用hexo g在.deploy_git文件夹中重新生成文件，推送，就好了。</p><p>总结一下，两边进程不同步，初始化.deploy_git文件夹即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树迭代遍历</title>
      <link href="/2024/09/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/09/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树迭代遍历"><a href="#二叉树迭代遍历" class="headerlink" title="二叉树迭代遍历"></a>二叉树迭代遍历</h2><p>本文参考：<a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p>二叉树的遍历使用递归是相当简单优雅的，但如何使用迭代实现？</p><p>对于二叉树的遍历，我将它想象成对一个二叉树结构洞穴的探索，冒险者就是实时锚点cur，而栈则是冒险者经过某些路口在地图上标记的信息</p><p>前序遍历（中左右）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先将根节点放入栈中，然后拿出，之后放入右左，由于后进先出，拿出来顺序就是左右，总的来说是这么个逻辑。那么每次都会将栈的最外面的元素作为cur，也就是目前的锚点，新元素的加入需要依靠这个锚点，也就是实时的《中》。在遍历的过程中，我们就将这个实时的锚点输出，也根据这个锚点更深一步探索这棵二叉树</p><p>中序遍历（左中右）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归算法可以通过简单地交换顺序实现前序和中序的转化，但是迭代就不行，究其原因是因为，对于前序遍历来说，搜索顺序和输出顺序是一样的，也就是实时的锚点也可以实时输出，而中序遍历不同，要实现左中右的顺序，首先我们需要找到那个最左的元素，而且我们需要记住一路上的节点，也就是要存到栈里，方便我们回找。想要中序遍历我们的策略就是尽可能地往左拐，走到死胡同就回来右拐一下，然后继续一直死命左拐</p><p>后序遍历（左右中）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历倒是可以由前序遍历稍加修改变换而成，先将中左右改成中右左，然后取反，就成了左右中，这一手还是很巧妙的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客日志（1）</title>
      <link href="/2024/09/03/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/"/>
      <url>/2024/09/03/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客的搭建方法"><a href="#本博客的搭建方法" class="headerlink" title="本博客的搭建方法"></a>本博客的搭建方法</h1><p>省流：Hexo框架 + Butterfly主题搭建博客</p><p>搭建方法主要参考：</p><p><a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p><p><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/">https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化Hexo</span><br><span class="line">hexo init MyBlog</span><br><span class="line"></span><br><span class="line">@_config.yml配置文件</span><br><span class="line">//修改基本信息，部署网址位置，这里我选择部署到github pages上（因为免费x</span><br><span class="line"></span><br><span class="line">//安装hexo框架中的git部署</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">*至此可以在公网上部署博客了，虽然是最基本的格式</span><br><span class="line"></span><br><span class="line">//安装butterfly主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">//安装渲染器插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br><span class="line">*至此可以实现butterfly主题的博客</span><br></pre></td></tr></table></figure><p>报错1：</p><p><img src="/./img/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/image-20240830140436370.png" alt="image-20240830140436370"></p><p>虽然只是个警告，但是这个警告表示找不到页面，到时候会打不开页面的，导致报错的原因是在主配置文件中将主题改成了butterfly（theme: butterfly），但是在theme文件夹里没有butterfly的原因</p><p>报错2：</p><p><img src="/./img/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/image-20240830142055295.png" alt="image-20240830142055295"></p><p>出现这个错误的原因只是因为没有安装渲染器插件，所以无法渲染页面而已（废话x</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About My Blog</title>
      <link href="/2024/09/03/About_My_Blog/"/>
      <url>/2024/09/03/About_My_Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="About-My-Blog"><a href="#About-My-Blog" class="headerlink" title="About My Blog"></a>About My Blog</h1><p>前言：在搭建这个博客的时候我已经快大二了，大学时光所剩不多，搭建这个博客除了作为存放学习笔记的地方，也是我告别迷茫大一开启新篇章的里程碑，希望未来的我能够大展拳脚，拥有一段精彩的大学生活。</p><p>​——致    未来的Youndry</p><p>由于本人的学习方法，本博客并不会事无巨细地整理记录，那样过于低效，本博客只是大概地记录学习过程中的关键过程，或者写一写自己的感悟。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/27/hello-world/"/>
      <url>/2024/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
