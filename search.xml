<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【初探Linux】进程管理</title>
      <link href="/2025/03/19/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2025/03/19/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/./img/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.assets/1135081469062947147.png" alt="实验楼"></p><hr><h2 id="理解Linux进程"><a href="#理解Linux进程" class="headerlink" title="理解Linux进程"></a>理解Linux进程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><p>我对于程序已经有了一定程度的认知——一段指令集合。那么进程又是什么，进程不应该就是一种程序吗？一个经典的例子，把程序比喻成菜谱，记录了做一道菜的过程，那么进程就是动手做出一道菜的过程。可以说，进程就是执行的程序，程序的一次执行。</p><p>程序是静态的，进程是动态的<strong>实体</strong></p><p>进程是操作系统进行资源分配和调度的基本单位。每个进程都有独立的内存空间、文件描述符、环境变量等资源，进程之间相互隔离，互不干扰。</p><p>进程具有并发性，也就是说，程序的执行并不一定是顺序的，是并发的，并发能够极大提高了程序的执行效率和资源利用率，于是引入线程的概念。</p><p><img src="/./img/Linux%E6%97%A5%E5%BF%97%EF%BC%884%EF%BC%89.assets/21b10a6fc224d5704279bbe987c4e67c.jpg" alt="21b10a6fc224d5704279bbe987c4e67c"></p><p>线程（Thread） 是进程中的一个执行单元，是CPU调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源，但每个线程有自己的栈和程序计数器。</p><p>多线程编程可以提高程序的并发性和响应性，但也需要注意线程安全问题（如竞态条件、死锁等）。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><strong>创建（New）</strong>：进程正在被创建。</p><p><strong>就绪（Ready）</strong>：进程已准备好运行，等待CPU分配时间片。</p><p><strong>运行（Running）</strong>：进程正在CPU上执行。</p><p><strong>阻塞（Blocked）</strong>：进程等待某些事件（如I&#x2F;O操作完成）而暂停执行。</p><p><strong>终止（Terminated）</strong>：进程执行完毕或被强制终止。</p><p><img src="/./img/Linux%E6%97%A5%E5%BF%97%EF%BC%884%EF%BC%89.assets/8c87b1dcc6efe3c59ad91892b5adb68e.jpg" alt="8c87b1dcc6efe3c59ad91892b5adb68e"></p><p>以上的进程分类是广义上的，对于特定的操作系统可能有更细化特殊的状态分类。</p><p>拓展：Linux进程状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R (Running / Runnable):进程正在运行或准备运行（在运行队列中等待CPU时间）。</span><br><span class="line">S (Interruptible Sleep):进程在等待某个事件（如I/O操作完成或信号），并且可以被信号中断。</span><br><span class="line">D (Uninterruptible Sleep):进程在等待I/O操作完成，且不会被信号中断。常见于磁盘I/O操作。</span><br><span class="line">Z (Zombie):进程已终止，但其父进程尚未回收其资源（如PID、退出状态等）。</span><br><span class="line">T (Stopped):进程被信号（如SIGSTOP）暂停，或正在被调试器跟踪。</span><br><span class="line">X (Dead):进程已完全终止，通常不会在ps或top的输出中看到。</span><br><span class="line">I (Idle):内核线程处于空闲状态，等待任务。</span><br><span class="line">t (Tracing stop):进程因被跟踪而暂停（如调试器）。</span><br><span class="line">W (Paging):进程正在等待分页（已废弃，现代内核中很少见）。</span><br><span class="line">K (Wakekill):进程正在等待不可中断的内核操作，且可被致命信号中断。</span><br><span class="line">P (Parked):进程被内核“停放”，通常用于内核线程。</span><br></pre></td></tr></table></figure><h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><p>​功能与服务：<strong>用户进程</strong>与<strong>系统进程</strong></p><p>​应用程序的服务类型：<strong>交互进程</strong>、<strong>批处理进程</strong>、<strong>守护进程</strong></p><ol><li>按功能与服务分类</li></ol><p>（1）<strong>用户进程（User Process）</strong></p><ul><li><strong>定义</strong>：由用户启动的进程，通常运行在用户空间。</li><li><strong>特点</strong>：<ul><li>执行用户编写的应用程序（如浏览器、文本编辑器、游戏等）。</li><li>权限受限，不能直接访问硬件或内核资源。</li><li>依赖于操作系统提供的系统调用（System Call）来访问底层资源。</li></ul></li><li><strong>示例</strong>：<ul><li>用户打开的Chrome浏览器进程。</li><li>用户运行的Python脚本进程。</li></ul></li></ul><p>（2）<strong>系统进程（System Process）</strong></p><ul><li><strong>定义</strong>：由操作系统内核启动和管理的进程，通常运行在内核空间。</li><li><strong>特点</strong>：<ul><li>负责管理硬件资源、内存、文件系统等。</li><li>具有较高的权限，可以直接访问硬件和内核资源。</li><li>通常是操作系统的核心组件。</li></ul></li><li><strong>示例</strong>：<ul><li>内存管理进程。</li><li>文件系统管理进程。</li><li>调度器进程。</li></ul></li></ul><ol start="2"><li>按应用程序的服务类型分类</li></ol><p>（1）<strong>交互进程（Interactive Process）</strong></p><ul><li><strong>定义</strong>：与用户直接交互的进程，通常需要用户输入并实时响应。</li><li><strong>特点</strong>：<ul><li>依赖于用户的输入（如键盘、鼠标）。</li><li>需要快速响应，对延迟敏感。</li><li>通常运行在前台。</li></ul></li><li><strong>示例</strong>：<ul><li>文本编辑器（如Vim、Notepad）。</li><li>图形界面应用程序（如浏览器、游戏）。</li></ul></li></ul><p>（2）<strong>批处理进程（Batch Process）</strong></p><ul><li><strong>定义</strong>：不需要用户交互，按预定义的任务列表自动执行的进程。</li><li><strong>特点</strong>：<ul><li>通常用于处理大量数据或执行重复性任务。</li><li>对实时性要求较低，注重吞吐量。</li><li>可以在后台运行。</li></ul></li><li><strong>示例</strong>：<ul><li>数据备份任务。</li><li>日志分析任务。</li><li>编译大型项目。</li></ul></li></ul><p>（3）<strong>守护进程（Daemon Process）</strong></p><ul><li><strong>定义</strong>：在后台运行的系统服务进程，通常没有用户界面。</li><li><strong>特点</strong>：<ul><li>在系统启动时自动运行，持续提供服务。</li><li>不依赖于用户交互。</li><li>通常以低优先级运行，避免影响系统性能。</li></ul></li><li><strong>示例</strong>：<ul><li>Web服务器（如Apache、Nginx）。</li><li>数据库服务（如MySQL、PostgreSQL）。</li><li>系统日志服务（如syslogd）。</li></ul></li></ul><ol start="3"><li>其他分类方式</li></ol><p>除了上述分类方式，进程还可以根据其他标准进行分类：</p><p>（1）<strong>按优先级分类</strong></p><ul><li><strong>实时进程（Real-Time Process）</strong>：对响应时间要求极高的进程（如音视频处理）。</li><li><strong>普通进程（Normal Process）</strong>：对响应时间要求较低的进程（如批处理任务）。</li></ul><p>（2）<strong>按资源占用分类</strong></p><ul><li><strong>CPU密集型进程</strong>：主要消耗CPU资源（如科学计算）。</li><li><strong>I&#x2F;O密集型进程</strong>：主要消耗I&#x2F;O资源（如文件读写、网络通信）。</li></ul><p>（3）<strong>按父子关系分类</strong></p><ul><li><strong>父进程（Parent Process）</strong>：创建其他进程的进程。</li><li><strong>子进程（Child Process）</strong>：由父进程创建的进程。</li></ul><table><thead><tr><th>分类方式</th><th>类型</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td><strong>功能与服务</strong></td><td>用户进程</td><td>由用户启动，运行在用户空间，权限受限</td><td>Chrome浏览器、文本编辑器</td></tr><tr><td></td><td>系统进程</td><td>由操作系统启动，运行在内核空间，权限较高</td><td>内存管理、文件系统管理</td></tr><tr><td><strong>服务类型</strong></td><td>交互进程</td><td>与用户直接交互，对实时性要求高</td><td>文本编辑器、图形界面应用程序</td></tr><tr><td></td><td>批处理进程</td><td>自动执行任务，注重吞吐量，无需用户交互</td><td>数据备份、日志分析</td></tr><tr><td></td><td>守护进程</td><td>后台运行，提供系统服务，无用户界面</td><td>Web服务器、数据库服务</td></tr></tbody></table><h3 id="进程衍生"><a href="#进程衍生" class="headerlink" title="进程衍生"></a>进程衍生</h3><p>由进程产生进程，进程之间是有<strong>家族关系</strong>的</p><p><img src="/./img/Linux%E6%97%A5%E5%BF%97%EF%BC%884%EF%BC%89.assets/f8e7e74dfdb653db93a57e7332dd9234.jpg" alt="f8e7e74dfdb653db93a57e7332dd9234"></p><p>关键词：父子进程，僵尸进程，孤儿进程，进程0，进程1</p><p>父进程产生子进程，通过<code>fork()</code>创建，子进程是父进程的副本</p><p>僵尸进程是系统资源已被回收但还未被父进程回收的进程，不占用系统资源但还有PID，占用进程表</p><p>孤儿进程是父进程不正常结束而导致没有父进程的进程，会被init进程收容接管</p><p>进程0，内核启动的第一个进程，是计算机启动时引导程序创建的最原始系统进程，负责<strong>初始化系统</strong>，进程0会产生进程1</p><p>进程1，init进程，用户空间的第一个进程，是始祖进程，产生其他所有进程，是所有进程的始祖，负责<strong>系统初始化</strong>和<strong>进程管理</strong></p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程组（Process Group）和会话（Session）</p><ol><li><strong>进程组（Process Group）</strong></li></ol><ul><li><strong>定义</strong>：<ul><li>进程组是一个或多个进程的集合，这些进程通常是由同一个父进程创建的，并且共享同一个进程组ID（PGID）。</li><li>进程组ID通常等于该组中第一个进程（组长进程）的进程ID（PID）。</li></ul></li><li><strong>作用</strong>：<ul><li>用于作业控制（Job Control），例如将一组进程作为一个整体进行管理（如暂停、恢复、终止）。</li><li>方便向一组进程发送信号（如<code>SIGKILL</code>、<code>SIGSTOP</code>）。</li></ul></li><li><strong>特点</strong>：<ul><li>每个进程都属于一个进程组。</li><li>进程组可以包含多个进程，但只能有一个组长进程。</li><li>进程组的存在与终端会话无关。</li></ul></li></ul><ol start="2"><li><strong>会话（Session）</strong></li></ol><ul><li><strong>定义</strong>：<ul><li>会话是一个或多个进程组的集合，通常与一个终端（Terminal）相关联。</li><li>每个会话有一个唯一的会话ID（SID），通常等于会话首进程（Session Leader）的进程ID（PID）。</li></ul></li><li><strong>作用</strong>：<ul><li>用于管理终端会话，例如用户登录后启动的所有进程都属于同一个会话。</li><li>控制终端的输入输出（如键盘输入、屏幕输出）。</li></ul></li><li><strong>特点</strong>：<ul><li>每个会话可以有一个控制终端（Controlling Terminal）。</li><li>会话中的进程组分为前台进程组（Foreground Process Group）和后台进程组（Background Process Group）。</li><li>前台进程组可以接收终端的输入和信号（如<code>SIGINT</code>），而后台进程组不能。</li></ul></li></ul><p>关键概念</p><ol><li><strong>进程组与会话的关系</strong></li></ol><ul><li>一个会话可以包含多个进程组，但只能有一个前台进程组。</li><li>进程组可以属于某个会话，但不能跨会话。</li></ul><ol start="2"><li><strong>前台进程组与后台进程组</strong></li></ol><ul><li><strong>前台进程组</strong>：<ul><li>与终端交互的进程组。</li><li>可以接收终端的输入（如键盘输入）和信号（如<code>SIGINT</code>）。</li></ul></li><li><strong>后台进程组</strong>：<ul><li>不与终端直接交互的进程组。</li><li>不能接收终端的输入，但可以接收信号。</li></ul></li></ul><ol start="3"><li><strong>会话首进程（Session Leader）</strong></li></ol><ul><li>创建会话的进程称为会话首进程。</li><li>会话首进程的PID通常等于会话ID（SID）。</li></ul><ol start="4"><li><strong>控制终端（Controlling Terminal）</strong></li></ol><ul><li>会话可以与一个终端关联，称为控制终端。</li><li>控制终端用于处理输入输出和信号。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【初探Linux】系统调用函数开发</title>
      <link href="/2025/03/18/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%80%E5%8F%91/"/>
      <url>/2025/03/18/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Linux内核系统调用开发流程？"><a href="#Linux内核系统调用开发流程？" class="headerlink" title="Linux内核系统调用开发流程？"></a>Linux内核系统调用开发流程？</h2><hr><p>省流：</p><p>1、kernel&#x2F;sys.c里实现函数</p><p>2、Include&#x2F;linux&#x2F;syscalls.h在系统调用表里声明</p><p>3、arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl里映射：462 ——&gt; sys_get_process_memory_info</p><p>4、make clean &amp;&amp; make -j$(nproc)编译内核</p><p>5、make install &amp;&amp; update-grub安装新内核，更新GRUB</p><p><img src="/./img/Linux%E6%97%A5%E5%BF%97%EF%BC%883%EF%BC%89.assets/928133-20171029182343008-410799515.png" alt="img"></p><hr><p><strong>获取源码</strong>：从<a href="https://www.kernel.org/">Linux官网</a>或Git仓库克隆内核源码。</p><p><strong>环境准备</strong>：安装编译工具和相关依赖。</p><p><strong>配置内核</strong>：使用<code>make menuconfig</code>等工具配置内核选项。 *****这一步就是开发过程</p><p><strong>编译内核</strong>：通过<code>make</code>命令编译内核和模块。</p><p><strong>安装内核</strong>：使用<code>make install</code>安装内核和<code>make modules_install</code>安装模块。</p><p><strong>更新引导程序</strong>：更新GRUB配置，确保系统使用新内核。</p><p><strong>测试内核</strong>：重启并验证新内核是否正常加载。</p><p><strong>提交补丁</strong>：编写和提交补丁，经过审查后合并到主线代码中。</p><hr><p>以<strong>实现简单的系统调用以读取进程内存信息</strong>的实验为例</p><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a><strong>获取源码</strong></h3><p>从<a href="https://www.kernel.org/">Linux官网</a>或Git仓库克隆内核源码。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h3><p>安装编译工具和相关依赖。</p><h3 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a><strong>配置内核</strong></h3><p>使用<code>make menuconfig</code>等工具配置内核选项。 *****这一步就是开发过程</p><h4 id="（1）实现新的系统调用"><a href="#（1）实现新的系统调用" class="headerlink" title="（1）实现新的系统调用"></a>（1）实现新的系统调用</h4><p>在<code>kernel/sys.c</code>文件中实现<code>sys_get_process_memory_info()</code>函数</p><p>系统调用是用户空间程序与内核空间交互的接口，允许用户程序请求内核执行特定操作。<code>sys.c</code>文件就是实现这些系统调用的地方。</p><p>系统调用服务例程：每个系统调用都对应一个内核服务例程来实现系统调用的功能</p><p>在<code>kernel/sys.c</code> 中如何编程？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sys.c 中编程</span></span><br><span class="line">SYSCALL_DEFINE2(get_process_memory_info, <span class="type">pid_t</span>, pid, <span class="keyword">struct</span> mem_info __user *, info)</span><br><span class="line"><span class="comment">// N=2，表示有2个参数</span></span><br><span class="line"><span class="comment">// get_process_memory_info是系统调用的名称</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/mem_info.h&gt;</span></span></span><br><span class="line">SYSCALL_DEFINE2(get_process_memory_info, <span class="type">pid_t</span>, pid, <span class="keyword">struct</span> mem_info __user *, info)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_info</span> <span class="title">mem_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 PID 查找任务结构体</span></span><br><span class="line">    task = find_task_by_vpid(pid);</span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ESRCH; <span class="comment">// 没有找到对应的进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程的内存描述符</span></span><br><span class="line">    mm = get_task_mm(task);</span><br><span class="line">    <span class="keyword">if</span> (!mm) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL; <span class="comment">// 无效的内存描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充内存信息</span></span><br><span class="line">    mem_info.start_code = mm-&gt;start_code;</span><br><span class="line">    mem_info.end_code = mm-&gt;end_code;</span><br><span class="line">    mem_info.start_data = mm-&gt;start_data;</span><br><span class="line">    mem_info.end_data = mm-&gt;end_data;</span><br><span class="line">    mem_info.start_stack = mm-&gt;start_stack;</span><br><span class="line">    mem_info.start_brk = mm-&gt;start_brk;</span><br><span class="line">    mem_info.brk = mm-&gt;brk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存描述符</span></span><br><span class="line">    mmput(mm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将内存信息复制到用户空间</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(info, &amp;mem_info, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mem_info))) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT; <span class="comment">// 复制到用户空间失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 各个头文件，提供了什么结构体和函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span>：进程调度相关。task_struct任务结构体（进程状态信息）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span>：内存管理相关。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span>：内核空间和用户空间之间数据交换。copy_to_user, copy_from_user</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/mem_info.h&gt;</span>:自定义的头文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以find_task_by_vpid(pid_t vnr)为例</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">find_task_by_vpid</span><span class="params">(<span class="type">pid_t</span> vnr)</span>;</span><br><span class="line"><span class="comment">// 通过PID找到相应进程的task_struct</span></span><br></pre></td></tr></table></figure><p>在编写过程中如何查询库函数的源码？也就是包含的头文件中的函数的源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借助工具 cscope</span></span><br><span class="line"><span class="comment">// 构建 cscope 数据库</span></span><br><span class="line">cscope -Rb</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入交互界面</span></span><br><span class="line">cscope -d</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在相应的搜索栏里寻找</span></span><br><span class="line"><span class="comment">// 进入文件</span></span><br><span class="line"><span class="comment">// 输入&quot;/balabala&quot;寻找 （会从光标当前位置往后寻找，可gg来到文件最开头）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以find_task_by_vpid(pid_t vnr)为例</span></span><br><span class="line"><span class="comment">// /find_task_by_vpid</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">find_task_by_vpid</span><span class="params">(<span class="type">pid_t</span> vnr)</span>;</span><br></pre></td></tr></table></figure><h4 id="（2）在系统调用表里声明函数"><a href="#（2）在系统调用表里声明函数" class="headerlink" title="（2）在系统调用表里声明函数"></a>（2）在系统调用表里声明函数</h4><p>系统调用表的作用是将用户程序发出的系统调用请求映射到相应的内核函数。当用户程序通过中断或陷阱进入内核模式时，操作系统会查找系统调用表，并根据系统调用号调用相应的内核函数来执行具体的操作。</p><p>系统调用表在<code>Include/linux/syscalls.h</code>，编写格式是<code>asmlinkage long sys_get_process_memory_info(pid_t pid, struct mem_info __user *info);</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/syscalls.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/mem_info.h&gt;</span> <span class="comment">// 处于方便，我把结构体mem_info单独放到了一个头文件里</span></span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_get_process_memory_info</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> mem_info __user *info)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/uapi/linux/Kbuild</span></span><br><span class="line">header-y += mem_info.h  <span class="comment">// header-y：这是一个变量，用来列出在构建过程中需要包含的头文件。</span></span><br><span class="line"><span class="comment">// 该行用于 Linux 内核的 Kbuild 系统，这是一个用于编译内核代码的构建系统，这里所说的构建就是之后的内核及内核模块的编译构建。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// include/uapi/linux/mem_info.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UAPI_LINUX_MEM_INFO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UAPI_LINUX_MEM_INFO_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> mem_info &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _UAPI_LINUX_MEM_INFO_H */</span></span></span><br></pre></td></tr></table></figure><h4 id="（3）系统调用映射表"><a href="#（3）系统调用映射表" class="headerlink" title="（3）系统调用映射表"></a>（3）系统调用映射表</h4><p><code>arch/x86/entry/syscalls/syscall_64.tbl</code>，系统调用映射表映射了每个系统调用号与内核中相应的系统调用函数之间的关系，当用户在应用程序中用到系统调用号时，会向内核请求调用映射的相应系统调用函数。</p><p>编写格式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统调用号 标志（通用） 系统调用</span></span><br><span class="line"><span class="number">462</span> common get_process_memory_info sys_get_process_memory_info</span><br></pre></td></tr></table></figure><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a><strong>编译内核</strong></h3><p>通过<code>make</code>命令编译内核和模块。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean &amp;&amp; make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure><h3 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a><strong>安装内核</strong></h3><p>使用<code>make install</code>安装内核和<code>make modules_install</code>安装模块。</p><h3 id="更新引导程序"><a href="#更新引导程序" class="headerlink" title="更新引导程序"></a><strong>更新引导程序</strong></h3><p>更新GRUB配置，确保系统使用新内核。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install &amp;&amp; update-grub</span><br></pre></td></tr></table></figure><h3 id="测试内核"><a href="#测试内核" class="headerlink" title="测试内核"></a><strong>测试内核</strong></h3><p>重启并验证新内核是否正常加载，<code>uname -r</code>。</p><p>本实验需要编写一个应用程序调用我们实现的系统调用函数，同时也是对系统调用函数的检验。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main/syscall_test/test1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_GET_PROCESS_MEMORY_INFO 462</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_info</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter PID:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">    <span class="type">long</span> result = syscall(SYS_GET_PROCESS_MEMORY_INFO, pid, &amp;info);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory info for process %d:\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Code: 0x%lx - 0x%lx\n&quot;</span>, info.start_code, info.end_code);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Data: 0x%lx - 0x%lx\n&quot;</span>, info.start_data, info.end_data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Stack: 0x%lx\n&quot;</span>, info.start_stack);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Heap: 0x%lx - 0x%lx\n&quot;</span>, info.start_brk, info.brk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to retrieve memory info for process %d, error: %s\n&quot;</span>,</span><br><span class="line">    pid, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功。</p><hr><p><strong>遇到的问题</strong></p><p>1、安装新内核5.10.234之后，WiFi模块似乎不兼容了，无法联网</p><p>2、写好系统调用实现之后编译时出现报错，undefined reference to <code>__x64___x64_sys_get_process_memory_info</code>，内核无法引用</p><p>3、运行用户空间程序，报错：Failed to retrieve memory info for process 35328, error: -1</p><p><strong>解决方法</strong></p><p>1、重新尝试安装内核6.8.1，WiFi终于可以用了</p><p>2、在syscall_64.tbl文件里注册时尝试修改之前的注册，注意到报错信息多了一个__x64_，在注册时改成</p><p>3、因为我错误地使用旧内核运行了该程序，使得调用函数失败，需要切换内核</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【初探Linux】文件结构及基本操作</title>
      <link href="/2025/03/13/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/13/%E3%80%90%E5%88%9D%E6%8E%A2Linux%E3%80%91%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux文件结构"><a href="#Linux文件结构" class="headerlink" title="Linux文件结构"></a>Linux文件结构</h2><p>文件组织结构：目录树状结构，FHS（Filesystem Hierarchy Stardard）标准</p><p><img src="/./img/Linux%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/4-1.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在Linux系统中，常见的文件夹及其全称如下：</span><br><span class="line"></span><br><span class="line">/bin - Binary（可执行文件）：包含系统启动和日常操作所需的基础命令程序。</span><br><span class="line">/boot - Boot（启动文件）：包含启动加载程序文件和系统启动所需的内核文件。</span><br><span class="line">/dev - Devices（设备文件）：存放设备文件，用于与硬件设备交互。</span><br><span class="line">/etc - Etcetera（配置文件）：存放系统的配置文件和管理脚本。</span><br><span class="line">/home - Home（用户目录）：包含所有用户的个人文件夹。</span><br><span class="line">/lib - Library（库文件）：存放共享库文件，支持程序运行。</span><br><span class="line">/lost+found - Lost and Found（丢失和找到的文件）：用于存放通过文件系统修复过程中恢复的文件。</span><br><span class="line">/media - Media（可移动存储设备）：挂载可移动存储设备的默认位置，如CD、USB等。</span><br><span class="line">/mnt - Mount（挂载点）：用于临时挂载文件系统。</span><br><span class="line">/opt - Optional（可选程序包）：包含额外的应用程序包，一般是第三方软件的安装目录。</span><br><span class="line">/proc - Process（进程文件）：包含内核和系统进程的信息，通常是虚拟文件系统。</span><br><span class="line">/root - Root（根用户的家目录）：根用户（超级用户）的个人文件夹。</span><br><span class="line">/run - Run（运行时数据）：存放系统运行时的状态信息，如系统进程的PID文件等。</span><br><span class="line">/sbin - System Binary（系统二进制文件）：包含系统管理和维护所需的二进制文件，通常只有管理员可以访问。</span><br><span class="line">/srv - Service（服务数据）：存放由系统提供的服务相关的数据。</span><br><span class="line">/sys - System（系统信息）：包含内核和设备的信息，通常是虚拟文件系统。</span><br><span class="line">/tmp - Temporary（临时文件）：用于存放临时文件，系统重启后通常会清空此目录。</span><br><span class="line">/usr - User（用户相关文件）：包含用户程序和共享数据，通常是系统安装时包含的大多数应用程序和库文件。</span><br><span class="line">/var - Variable（可变数据）：存放系统运行时变化的文件，如日志文件、缓存、邮件等。</span><br></pre></td></tr></table></figure><hr><h2 id="Q、文件的基本操作有哪些？"><a href="#Q、文件的基本操作有哪些？" class="headerlink" title="Q、文件的基本操作有哪些？"></a>Q、文件的基本操作有哪些？</h2><p>新建、复制、删除、移动文件与重命名、查看文件、查看文件类型、搜索文件。</p><p>新建：</p><p>​touch filename 创建文件，如果文件存在那么就会更新时间戳</p><p>​mkdir direction_name、mkdir -p dir_p&#x2F;dir_s(if dir_p do not exist) 文件夹和文件不可同名（everything is a file）文件夹本质也是文件</p><p>复制：cp file target_dir、cp dir target_dir -r</p><p>删除：rm file、rm dir -r、rm file -f（题外话 chmod 444 file 给文件施加写保护</p><p>移动文件与重命名：mv file target_dir、mv file_old file_new</p><p>查看文件：cat file、cat -n flie 标上行数、nl -b a filename(&#x3D;cat -n)、more filenane 功能强大、head&#x2F;tail filename (-f 实时读取)</p><p>查看文件类型：file filename Linux中文件类型不根据文件后缀判断，根据文件内容判断</p><p>搜索文件：</p><p>​whereis filename </p><p>​find target_dir file、file [path] [option]  [action]、find target_dir -name filename、file target_dir -mtime 0（列出目标文件夹中24小时内修改过的文件）</p><p>​locate target_dir file：apt-get update、apt-get install locate、updatedb、locate target_dir file   locate命令通过mlocate.db数据库来检索信息，需要手动安装，更新</p><p>​which filename 通常用来确定是否成功安装某程序，只从PATH指定路径下搜索命令并返回第一个搜索到的结果</p><hr><p>参考链接：<a href="https://www.lanqiao.cn/courses/2585/learning/">蓝桥云课-Linux</a></p><hr><p>tips：nohup xeyes &amp; :eyes:</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【代码随想录】二叉树（1）</title>
      <link href="/2025/02/23/%E3%80%90%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%89/"/>
      <url>/2025/02/23/%E3%80%90%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前言：最近一个学习小组里大家约定每天刷算法题（虽然近期因为题目难度变难变为了两天一道），没想到的是几个组员居然不约而同地说出了代码随想录这个名字，正是“英雄所见略同”，最近已经是刷了有一阵子了，期间虽然偶然有做笔记，又因为这样那样的事情写得断断续续很零碎，实在凑不出一篇博客来，最近写到了二叉树，有了些感悟和时间，正好整理出篇博客来记录。</p><p>代码随想录：<a href="https://www.programmercarl.com/">https://www.programmercarl.com/</a></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><hr><h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><p>递归：在函数的定义中使用函数自身的方法</p><p>因为二叉树的左右子树还是二叉树，所以可以使用递归的方法。前中后序遍历时使用递归则可以写出非常简洁优美的代码，并且在前中后切换时也仅仅只需要改变几行代码之间的顺序，代码的结构是保持不变的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历·递归·LC144_二叉树的前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorder(root.left, result);</span><br><span class="line">        preorder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历·递归·LC94_二叉树的中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历·递归·LC145_二叉树的后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a><strong>二叉树的迭代遍历</strong></h3><p>迭代是什么？<strong>迭代</strong>是重复反馈过程的活动，其目的通常是为了接近并且到达所需的目标或结果。 每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。</p><p>那么如何在遍历二叉树时使用迭代？循环，我们需要想出一套流程，使得问题能够在一次又一次循环地执行流程得到解决，并且我们需要把每次循环之后的输出作为下一次的输入，因为是同一套流程，也就是每次循环它所处的情景都有着相似性，在循环中推进问题的解决，螺旋式前进。从这个角度来看，迭代和递归有着相似之处。至于输出的顺序，我们可以使用<strong>栈</strong>这种有序的数据结构实现。</p><p>既然和递归相似，那么前中后三种情形之间的转化应当是简单的，形式不变的，但是目前我们的这种方法似乎只能够前后序遍历之间转化，而中序遍历则需要大幅度地修改。</p><p><strong>前序遍历</strong>：根左右，每一个节点都需要当作一次根，来寻找其子节点，那么我们将一个节点输出栈后，以这个节点为根寻找其左右节点放入栈，注意顺序，最终顺序是根左右，那么放入的顺序就是先右后左，重复这个过程，即可实现前序遍历。</p><p><strong>后序遍历</strong>：接着先来看看后续遍历，左右根，我们注意到根仍然处于三者的边缘，是如果巧妙地将左右互换，变成右左根，那么就可以发现和前序遍历完全对称了。于是我们在前序遍历的基础上稍事修改 ，使得输出变为右左根，在将结果反转，即可实现后序遍历。</p><p><strong>中序遍历</strong>：中序遍历似乎和前后序遍历并没有对称的强关联，然而正是这点给我们造成了麻烦，因为前后序遍历的情况下，每次我们都会把当前的根节点剔出栈，而中序遍历则不能这样，我们需要保留这个当前的根节点让它等一会轮到它的时候再出栈，但是当我们应付好它之前的节点轮到它时，我们会无从得知它是当时我们的根节点，我们也就不知道它的左右节点（如果有的话）已经被我们处理过放入栈了，于是我们像对待其他节点一样再次将它的左右节点放入栈，这就形成了问题。于是我们退而求其次，将中序遍历特殊对待，我们模拟自己寻找的过程，先要找到最左边的节点，输出左节点，在输出其根节点，然后我们去找右节点（如果有的话），当我们找到右节点之后，我们会发现，自己又需要先找到最左边的节点，至此，循环成立，迭代成立。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a><strong>二叉树的统一迭代法</strong></h3><p>上文的二叉树迭代遍历可以看到，前后序遍历是可以转化的，而中序遍历则与前后序遍历的很不同，而我们也巧妙地找到了左右序遍历和中序遍历时的循环，前后序遍历的转化和中序遍历循环的寻找都是让人鼓掌叫好的巧思。那么事情就只能到此为止了吗，毕竟目前的解法看起来实现算不上优雅，中序遍历和前后序遍历完全不同，而前后序遍历严格上来说也因为最后的翻转操作并不完全统一。那么能否实现格式相同的前后中序迭代遍历呢？首先我们要知道为什么上文的迭代法和递归不同，因为上文的迭代法中的中序遍历，由于我们需要将当前的根节点先存放在栈中，而我们又无法区分栈中哪些是已经做过根节点的节点，而我们的解决方法是先确定左节点，等左节点剔出后，栈中露出来的自然就是它的根节点，我们事实上变相地“标记”了哪些是曾经的根节点，那么我们可以尝试其他的标记方法，这里采用的方式一种是直接在曾经的根节点后面放上一个空节点作为标记，一种则更加简单粗暴，直接给每个节点增加一个字段用于标记。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加null标记</span></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加字段标记</span></span><br><span class="line"><span class="comment">// 以前序遍历为例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    Command(TreeNode node, <span class="type">int</span> type)&#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;Command&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Command</span>(root, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (command.type == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (command.node.right != <span class="literal">null</span>) stack.push(<span class="keyword">new</span> <span class="title class_">Command</span>(command.node.right, <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">if</span> (command.node.left != <span class="literal">null</span>) stack.push(<span class="keyword">new</span> <span class="title class_">Command</span>(command.node.left, <span class="number">0</span>));</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Command</span>(command.node, <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(command.node.val);</span><br><span class="line">                System.out.println(command.node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】动态查找表</title>
      <link href="/2025/01/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/"/>
      <url>/2025/01/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h2><p>动态查找表，表结构本身是在查找过程中动态生成的，动态更新意味着适合使用指针</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树：<strong>构造的过程就是排序的过程</strong>，在无序的关键字序列中，在既有的二叉排序树（一开始的二叉排序树是一个空树）中查询一个个关键字应该所在的位置，往二叉排序树一个个添加，最后只需要对生成的二叉排序树进行中序遍历就可以得到有序的关键字序列了</p><p>在实际应用中，平衡二叉树有其弊端——在数据量大的情况下深度太大，因为每当访问一个节点的时候，我们需要进行更多的比较（每层都要比较选择进入哪个子树），不过消耗时间主要不是在内存中元素之间的比较，而是每次进入一个节点时都需要进行磁盘<strong>I&#x2F;O读取</strong>，那么为了减少时间消耗，我们现在需要的就是尽量减少树的深度，引入B-树这种数据结构</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树要尽量减少树的深度，为了达到这个目的，B-树增加了可拥有子节点的上限；还有要提高每个节点的利用率（不要存储太少的元素），设置一个下限，每个节点的子节点（M个）保持在 <code>(m/2)-1(向上取整）&lt;= M &lt;= m </code>之间，下限取<code>m/2（向上取整）-1</code>是考虑到节点之间的合并操作，低于<code>m/2</code>才能进行合并操作，合并时候是两个子节点（一个<code>(m/2)-2</code>和一个<code>(m/2)-1</code>）和父节点的一个元素合并，也就是说合并后的节点会不会超过上限；还有要保证所有叶子节点不要参差不齐，保持在同一层，这也有利于树深度的降低</p><p>初步接触B-树这种数据结构，直觉来看相较于平衡二叉树那种明显严密的结构更加杂乱，特别是在动态更新中元素的<strong>插入</strong>和<strong>删除</strong>，元素的插入和删除会分很多种情况，每种情况都会有相应的处理方式，而且相较于平衡二叉树的变化，B-树的变化更加复杂，有时候会牵一发动全身，一个元素的增删可能会引起很大的结构变化，不过剖析每种情况后也对其严密的逻辑有了相对直观的认识，B-树是一种和平衡二叉树差不多的分叉更多而深度更小的数据结构，虽然B-树的查找过程中比较次数并不比平衡二叉树少，但访问节点次数少了很多，节省了时间消耗</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是在B-树基础上进一步改进，结构、动态变化方式和B-树基本相同，不同的是B+树拥有<code>k</code>个子树的节点拥有<code>k</code>个元素，而且中间节点的元素仅包含指向子树的指针，不包含指向数据的指针，也就是说，中间节点不包含卫星数据（指针指向的数据记录），叶子节点包含了所有数据。精简了中间节点，使得同一磁盘页可以包含更多的元素，也就是可以更多分叉，进一步降低树的深度，降低查询时IO次数；同时相较于B-树，B+树的每次查询都需要从根节点出发一直到达叶子节点完成一次查询，这使得每次查询消耗时间更加稳定；还有就是B+树的所有叶子节点通过指针链接起来，形成一条<strong>有序链表</strong>，这有利于对元素进行顺序遍历（B-树中的遍历需要通过<strong>中序遍历</strong>实现），以及有利于进行数据库中的常用操作——范围查找（从数据集中查询满足特定范围条件的数据）。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://wardseptember.github.io/notes/#/docs/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E8%AF%A6%E8%A7%A3">https://wardseptember.github.io/notes/#/docs/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E8%AF%A6%E8%A7%A3</a></p><p><a href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p><p><a href="https://zhuanlan.zhihu.com/p/54102723">https://zhuanlan.zhihu.com/p/54102723</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TodoList日志（1）</title>
      <link href="/2024/12/02/TodoList%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/"/>
      <url>/2024/12/02/TodoList%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="TodoList设计"><a href="#TodoList设计" class="headerlink" title="TodoList设计"></a>TodoList设计</h1><p>这是创新实践课程的作业，做一个简单的TodoList应用，借这个机会把整个业务开发的流程熟悉一遍。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="功能调研"><a href="#功能调研" class="headerlink" title="功能调研"></a><strong>功能调研</strong></h3><p>TODO 应用通常是一个帮助用户管理日常任务的工具，用户可以在其中创建、查看、编辑、删除任务，并通过标记任务状态来追踪进度。常见的功能包括：</p><ol><li><strong>创建任务</strong>：允许用户输入任务标题、描述、优先级、截止日期等信息。</li><li><strong>查看任务</strong>：展示所有任务，并按状态（如已完成、未完成）进行过滤。</li><li><strong>编辑任务</strong>：让用户修改任务的内容、截止日期等。</li><li><strong>删除任务</strong>：删除已不再需要的任务。</li><li><strong>标记任务完成&#x2F;未完成</strong>：允许用户标记任务的完成状态，帮助跟踪进度。</li></ol><p>此外，一些TODO应用还可能包括任务提醒、优先级设置、任务分类、搜索功能等扩展功能。</p><p><strong>核心功能</strong></p><p>这些是项目的基本功能，优先实现基本功能，扩展功能之后再说。</p><ol><li><strong>创建任务</strong>：用户可以添加新的任务，任务包含标题、描述和截止日期（可选）。任务可以标记为已完成或未完成。<ul><li>输入框：任务标题、任务描述、截止日期。</li><li>按钮：保存、取消。</li></ul></li><li><strong>查看任务</strong>：用户可以查看所有任务，并过滤选项：全部任务、未完成任务、已完成任务。。<ul><li>列表展示：任务标题、描述、状态、截止日期。</li><li>过滤选项：全部任务、未完成任务、已完成任务。</li></ul></li><li><strong>编辑任务</strong>：用户可以修改已创建的任务，包括修改标题、描述、截止日期。<ul><li>编辑按钮：任务列表中的每个任务旁边都有一个编辑按钮，复用创建窗口。</li></ul></li><li><strong>删除任务</strong>：用户可以删除不再需要的任务。<ul><li>删除按钮：任务列表中的每个任务旁边都有一个删除按钮，用户需确认是否删除。</li></ul></li><li><strong>标记完成&#x2F;未完成</strong>：用户可以将任务标记为“完成”或“未完成”状态。<ul><li>完成按钮：标记任务状态的交互元素。</li></ul></li></ol><h2 id="原型设计"><a href="#原型设计" class="headerlink" title="原型设计"></a>原型设计</h2><p>web网页版 Todo List 主页面 左边是导航栏 右边是任务列表，每条任务包含任务标题，距离截止的时间，完成圆圈，编辑按钮，删除按钮</p><p>任务列表，一条一条的任务，包含任务标题，距离截止的时间，完成圆圈，编辑按钮，删除按钮</p><p>搜索框（请输入想查找的任务）</p><p>新增任务的加号按钮</p><p><img src="/./img/TodoList%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/%E9%A1%B5%E9%9D%A2%E5%8E%9F%E5%9E%8B.png" alt="页面原型"></p><h2 id="TODO-应用-API-文档"><a href="#TODO-应用-API-文档" class="headerlink" title="TODO 应用 API 文档"></a><strong>TODO 应用 API 文档</strong></h2><h3 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1. 创建任务"></a><strong>1. 创建任务</strong></h3><ul><li><strong>请求类型</strong>：<code>POST</code></li><li><strong>请求路径</strong>：<code>/api/tasks</code></li><li><strong>请求参数</strong>：<ul><li><code>title</code>（必填）：任务标题（字符串，最大长度 255）</li><li><code>description</code>（可选）：任务描述（字符串）</li><li><code>dueDate</code>（可选）：任务截止日期（ISO 8601 格式字符串，如：<code>2024-12-25T12:00:00Z</code>）</li><li><code>status</code>（可选）：任务状态，默认值为 <code>pending</code>（<code>pending</code> 或 <code>completed</code>）</li><li><code>priority</code>（可选）：任务优先级（字符串，可选值：<code>low</code>，<code>medium</code>，<code>high</code>）</li></ul></li><li><strong>请求示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;完成TODO应用API文档&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;编写详细的API文档，包含每个功能的请求和响应示例。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dueDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-10T12:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;high&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>响应：</p><ul><li><p><strong>成功响应</strong>：</p><ul><li>状态码：<code>201 Created</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;完成TODO应用API文档&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;编写详细的API文档，包含每个功能的请求和响应示例。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dueDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-10T12:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pending&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;high&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;createdAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;updatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>失败响应</strong>：</p><ul><li>状态码：<code>400 Bad Request</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Title is required&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="2-查看任务"><a href="#2-查看任务" class="headerlink" title="2. 查看任务"></a><strong>2. 查看任务</strong></h3><ul><li><strong>请求类型</strong>：<code>GET</code></li><li><strong>请求路径</strong>：<code>/api/tasks</code></li><li><strong>请求参数</strong>：<ul><li><code>status</code>（可选）：任务状态过滤选项，值为 <code>all</code>（所有任务），<code>pending</code>（未完成任务），<code>completed</code>（已完成任务）。默认值为 <code>all</code>。</li><li><code>priority</code>（可选）：任务优先级过滤选项，值为 <code>low</code>、<code>medium</code>、<code>high</code>，支持多选。</li></ul></li><li><strong>请求示例</strong>：</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /api/tasks?status=all&amp;priority=high</span><br></pre></td></tr></table></figure><ul><li><p>响应：</p><ul><li><p><strong>成功响应</strong>：</p><ul><li>状态码：<code>200 OK</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;完成TODO应用API文档&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;编写详细的API文档，包含每个功能的请求和响应示例。&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dueDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-10T12:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pending&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;high&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createdAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>失败响应</strong>：</p><ul><li>状态码：<code>400 Bad Request</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Invalid filter options&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="3-编辑任务"><a href="#3-编辑任务" class="headerlink" title="3. 编辑任务"></a><strong>3. 编辑任务</strong></h3><ul><li><strong>请求类型</strong>：<code>PUT</code></li><li><strong>请求路径</strong>：<code>/api/tasks/&#123;id&#125;</code></li><li><strong>请求参数</strong>：<ul><li><code>title</code>（可选）：任务标题</li><li><code>description</code>（可选）：任务描述</li><li><code>dueDate</code>（可选）：任务截止日期</li><li><code>status</code>（可选）：任务状态（<code>pending</code> 或 <code>completed</code>）</li><li><code>priority</code>（可选）：任务优先级（<code>low</code>、<code>medium</code>、<code>high</code>）</li></ul></li><li><strong>请求示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;更新TODO应用API文档&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;更新API文档，包含最新的功能描述。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dueDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-12T12:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;medium&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>响应：</p><ul><li><p><strong>成功响应</strong>：</p><ul><li>状态码：<code>200 OK</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;更新TODO应用API文档&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;更新API文档，包含最新的功能描述。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dueDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-12T12:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pending&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;medium&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;createdAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;updatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-01T10:00:00Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>失败响应</strong>：</p><ul><li>状态码：<code>400 Bad Request</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Invalid task ID&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="4-删除任务"><a href="#4-删除任务" class="headerlink" title="4. 删除任务"></a><strong>4. 删除任务</strong></h3><ul><li><strong>请求类型</strong>：<code>DELETE</code></li><li><strong>请求路径</strong>：<code>/api/tasks/&#123;id&#125;</code></li><li><strong>请求参数</strong>：无（通过 URL 提供任务的 <code>id</code>）</li><li><strong>请求示例</strong>：</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE /api/tasks/1</span><br></pre></td></tr></table></figure><ul><li><p>响应：</p><ul><li><p><strong>成功响应</strong>：</p><ul><li>状态码：<code>204 No Content</code></li><li>响应体：无</li></ul></li><li><p><strong>失败响应</strong>：</p><ul><li>状态码：<code>404 Not Found</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task not found&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="5-标记任务完成-未完成"><a href="#5-标记任务完成-未完成" class="headerlink" title="5. 标记任务完成&#x2F;未完成"></a><strong>5. 标记任务完成&#x2F;未完成</strong></h3><ul><li><strong>请求类型</strong>：<code>PATCH</code></li><li><strong>请求路径</strong>：<code>/api/tasks/&#123;id&#125;/status</code></li><li><strong>请求参数</strong>：<ul><li><code>status</code>（必填）：任务的新状态，值为 <code>pending</code> 或 <code>completed</code>。</li></ul></li><li><strong>请求示例</strong>：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completed&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>响应：</p><ul><li><p><strong>成功响应</strong>：</p><ul><li>状态码：<code>200 OK</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;完成TODO应用API文档&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;编写详细的API文档，包含每个功能的请求和响应示例。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dueDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-10T12:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completed&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;high&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;createdAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;updatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-11-30T10:00:00Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>失败响应</strong>：</p><ul><li>状态码：<code>400 Bad Request</code></li><li>响应体：</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Invalid status value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营X豆包MarsCode】第六课-走进消息队列</title>
      <link href="/2024/11/30/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E5%85%AD%E8%AF%BE-%E8%B5%B0%E8%BF%9B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2024/11/30/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E5%85%AD%E8%AF%BE-%E8%B5%B0%E8%BF%9B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="走进消息队列"><a href="#走进消息队列" class="headerlink" title="走进消息队列"></a>走进消息队列</h1><h2 id="消息队列前世今生"><a href="#消息队列前世今生" class="headerlink" title="消息队列前世今生"></a>消息队列前世今生</h2><p>在现代分布式系统中，消息队列（Message Queue，简称 MQ）已成为一种不可或缺的中间件，用于解耦系统组件、提高系统可靠性与扩展性。消息队列的出现和发展，与以下几个系统问题密切相关：</p><p><strong>系统崩溃</strong>：</p><ul><li>在高并发系统中，直接处理请求可能导致系统崩溃。通过将请求先放入消息队列，系统可以避免瞬时过载，确保稳定运行，等待后端存储服务逐步处理这些请求。</li></ul><p><strong>服务处理能力有限</strong>：</p><ul><li>当系统的处理能力达到瓶颈时，前端请求会迅速堆积，造成系统崩溃。此时可以将请求放入消息队列，按需逐步消费，避免一瞬间的请求涌入导致服务过载。</li></ul><p><strong>链路耗时长尾</strong>：</p><ul><li>在一些分布式系统中，某些链路的处理时间可能会较长，导致长尾效应。通过异步方式将请求投递到消息队列中，避免长时间等待影响系统整体性能。</li></ul><p><strong>日志存储</strong>：</p><ul><li>在分布式系统中，日志的存储与分析是关键环节。将日志数据发送到消息队列后，后端日志分析平台可以异步获取数据，进行实时或定期分析。</li></ul><p><strong>什么是消息队列？</strong></p><p>消息队列（MQ）是一个用于存储和传输消息的容器，其本质上是一个先进先出（FIFO）的队列。在分布式系统中，消息队列通常具有以下特点：</p><ul><li><strong>高吞吐</strong>：能够处理大量的消息，确保高并发场景下的稳定性。</li><li><strong>高可用</strong>：消息队列需具备容错能力，保证数据不丢失。</li><li><strong>高并发</strong>：能够支持多个生产者和消费者并发工作。</li></ul><p>系统中，消息生产者将消息发送到消息队列，消费者从队列中获取并处理消息。通过消息队列，可以实现系统的解耦和异步处理。</p><p>生产 ——&gt; 消息队列 ——&gt; 消费</p><p>业界消息队列：Kafka、RocketMQ、Pulsar、BMQ</p><h2 id="消息队列-Kafka"><a href="#消息队列-Kafka" class="headerlink" title="消息队列 - Kafka"></a>消息队列 - Kafka</h2><p>Kafka 是一个高吞吐量的分布式消息队列，广泛应用于 <strong>离线数据处理</strong>、<strong>日志收集</strong>、<strong>指标数据监控</strong>、<strong>用户行为追踪</strong> 等场景。</p><p><strong>如何使用 Kafka</strong></p><p>创建集群 ——&gt; 新增 Topic ——&gt; 编写生产者逻辑 ——&gt; 编写消费者逻辑</p><p>​<strong>创建集群</strong>：部署 Kafka 集群并进行配置。</p><p>​<strong>新增 Topic</strong>：创建 Topic 作为消息的逻辑队列。</p><p>​<strong>编写生产者逻辑</strong>：将消息发送到 Kafka 集群中的指定 Topic。</p><p>​<strong>编写消费者逻辑</strong>：从 Kafka 中的 Topic 获取消息进行消费。</p><p><strong>Kafka 架构</strong></p><ul><li><strong>Producer</strong>：生产者，批量发送Batch、数据压缩，负责将消息发送到 Kafka 集群。生产者支持批量发送和消息压缩，提升吞吐量。</li><li><strong>Broker</strong>：Kafka 的消息存储和转发节点。每个 Broker 存储一定数量的分区数据。顺序写、时间戳索引文件、零拷贝。</li><li><strong>Consumer</strong>：消费者，负责从 Kafka 中消费消息。消费者可以是独立消费或分组消费（Consumer Group）。手动分配（Low Level）、自动分配（High Level）、Consumer Rebalance。</li></ul><p>Topic 逻辑队列</p><p>Cluster 物理集群</p><p>Producer 生产者</p><p>Consumer 消费者</p><p>ConsumerGroup 消费者组</p><p><strong>Kafka 核心组件</strong></p><ul><li><strong>ZooKeeper</strong>：用于管理 Kafka 集群的元数据和节点信息。</li><li><strong>Partition</strong>：Kafka 中的消息按分区存储，每个 Topic 可以有多个分区。</li><li><strong>Consumer Group</strong>：消费者组，允许多个消费者协作消费同一 Topic 下的消息。</li></ul><p><strong>Kafka 工作原理</strong></p><p>​Leader 和 Follower</p><ul><li>每个 Partition 有一个 Leader 和多个 Follower，Leader 负责所有的读写操作，Follower 负责复制数据。</li></ul><p>​消费者平衡（Consumer Rebalance）</p><ul><li>消费者组中的消费者通过自动或手动分配机制（Low Level &#x2F; High Level）获取消息。</li></ul><p><strong>Kafka 的挑战与问题</strong></p><p>​<strong>运维成本高</strong>：Kafka 集群的维护与管理需要较高的运维成本，尤其在集群扩容和负载均衡方面。</p><p>​<strong>负载不均衡</strong>：当某些分区数据量过大时，可能导致负载不均衡的问题，处理起来比较复杂。</p><p>​<strong>无缓存机制</strong>：Kafka 没有内建缓存机制，完全依赖操作系统的 Page Cache，可能会影响性能。</p><p>​<strong>多进程问题</strong>：Controller、Coordinator 和 Broker 在同一进程中，频繁的 IO 操作可能导致性能瓶颈。</p><h2 id="消息队列-BMQ"><a href="#消息队列-BMQ" class="headerlink" title="消息队列 - BMQ"></a>消息队列 - BMQ</h2><p><strong>BMQ（字节跳动消息队列）</strong></p><p>BMQ 是字节跳动内部开发的高性能、高可靠性的消息队列系统，旨在解决传统消息队列（如 Kafka）在高并发、大规模分布式环境下遇到的性能瓶颈和操作复杂性。BMQ 强调灵活的扩展能力、稳定性以及高效的数据流处理，支持多种高级特性来应对复杂的应用场景。</p><p><strong>BMQ 的架构模式</strong></p><p>BMQ 的架构设计旨在克服 Kafka 等传统消息队列系统中的一些问题：</p><ol><li><strong>高负载和不均衡</strong>：在 Kafka 中，负载均衡和消费者分配的管理较为复杂，且处理大量数据时容易造成节点压力过大。</li><li><strong>性能瓶颈</strong>：Kafka 对于高吞吐量的数据写入和低延迟的处理场景有所欠缺，尤其在需要频繁更新或读取的场景下。</li><li><strong>单点故障和高可用性</strong>：尽管 Kafka 支持分布式部署，但仍然面临因单个节点故障导致整个集群性能下降的风险。</li></ol><p>BMQ 通过以下几个设计解决了这些问题：</p><ul><li><strong>多机房部署</strong>：BMQ 支持跨多个数据中心和机房的部署，保证了高可用性和灾难恢复。多个机房的数据同步和负载均衡可以确保即使某一机房出现故障，消息队列仍能正常工作。</li><li><strong>Partition 状态机</strong>：BMQ 采用状态机来管理消息的生命周期，从消息的生成、传输、存储到消费等各个环节都通过状态机进行高效的控制和管理。这种设计能够有效避免 Kafka 中可能出现的消息丢失、重复消费等问题。</li><li><strong>Proxy 层</strong>：BMQ 的 Proxy 层位于客户端和 Broker 之间，负责消息的路由、负载均衡和流控。通过 Proxy，BMQ 可以动态地调整消息的路由规则和策略，进一步提升系统的可扩展性和容错能力。</li></ul><p><strong>BMQ 读写流程</strong></p><p>BMQ 的读写流程基于 <strong>Failover 机制</strong> 和 <strong>写入状态机</strong>，确保在高并发和复杂的分布式环境下，消息可以高效、可靠地流转。</p><ol><li><strong>写入流程</strong>：<ul><li><strong>Failover 机制</strong>：BMQ 采用容错机制，保证在 Broker 节点故障时，消息能够自动路由到其他可用节点，避免消息丢失。</li><li><strong>写入状态机</strong>：每个消息在写入时都会经过状态机的管理，确保消息在存储过程中状态的正确转换。比如，消息在入队时的 “待处理” 状态，处理后进入 “已消费” 状态，避免消息丢失或重复消费。</li></ul></li><li><strong>消费流程</strong>：<ul><li>消费者通过订阅消息队列，按照队列的负载均衡规则，从多个队列分区中拉取消息。BMQ 的消费策略既支持单个消费者消费整个队列，也支持消费者组（Consumer Group）进行负载均衡消费。</li></ul></li><li><strong>消息的可靠性保障</strong>：<ul><li>消息的可靠性不仅体现在消息写入和消费过程中的状态机控制，也通过 <strong>数据镜像（Mirror）</strong> 来确保数据在多个数据中心的同步备份。BMQ 可以对消息进行多副本存储，确保数据的高可用性。</li></ul></li></ol><p><strong>BMQ 的高级特性</strong></p><p>BMQ 提供了一些特殊的功能和特性来满足复杂业务场景中的需求：</p><ol><li><strong>主干与泳道（Lane）消息</strong>：<ul><li><strong>主干消息</strong>：主要负责关键业务流的高效传输，通常处理较高优先级的消息。主干消息的处理链路通常具有较低的延迟。</li><li><strong>泳道消息</strong>：用于低优先级或大批量的消息流。这些消息在主干消息流中会有独立的处理链路，并且可以异步处理。泳道设计支持消息的隔离和优先级调度。</li></ul></li><li><strong>Databus（数据总线）</strong>：<ul><li><strong>Databus</strong> 是 BMQ 中的一种数据同步和传递机制，允许多个服务间同步传递和共享实时数据。Databus 可以帮助解决跨服务的数据传递问题，特别是在微服务架构中，Databus 提供了一种高效且低延迟的数据流传输方式。</li></ul></li><li><strong>Mirror（镜像机制）</strong>：<ul><li><strong>镜像机制</strong> 用于跨机房或跨数据中心的数据备份。通过将消息数据同步到不同的节点或机房，BMQ 提供了灾备功能，确保系统在某个节点故障时仍能保持服务的持续可用性。</li></ul></li><li><strong>Index（索引）</strong>：<ul><li>BMQ 支持对消息内容进行索引，可以快速定位到特定的消息。这个索引功能对于一些高并发的查询和检索操作非常有用，尤其是在日志处理或审计系统中。</li></ul></li><li><strong>Parquet（列式存储格式）</strong>：<ul><li><strong>Parquet</strong> 是一种列式存储格式，BMQ 支持将消息存储为 Parquet 格式，这种存储方式非常适合于大规模数据分析场景。通过列式存储，BMQ 可以更加高效地存储和处理大量的日志或监控数据。</li></ul></li></ol><p><strong>BMQ 的开发流程</strong></p><p>BMQ 的开发和部署流程通常包括以下几个步骤：</p><ol><li><strong>开发阶段</strong>：<ul><li>开发人员编写消息生产者和消费者的逻辑，使用 BMQ 提供的 SDK 或 API 接口来实现消息的生产与消费。</li></ul></li><li><strong>BOE（线下测试环境）</strong>：<ul><li>开发完成后，将应用部署到 BOE（测试环境）进行基础功能的验证和性能测试。此阶段主要验证消息队列的基本功能是否正常，如消息的生产、消费、消息顺序等。</li></ul></li><li><strong>PPE（验证环境）</strong>：<ul><li>将应用部署到 PPE 环境，进行更为全面的集成测试。此阶段除了验证基础功能外，还包括高并发、大数据量场景下的性能测试，确保系统在负载下能够稳定运行。</li></ul></li><li><strong>Prod（生产环境）</strong>：<ul><li>最终，经过验证的应用会部署到生产环境，供实际业务使用。生产环境中的消息队列需要确保高可用性、容错性和性能，BMQ 在这一阶段通过多机房部署和数据镜像来保证稳定性。</li></ul></li></ol><p><strong>小结</strong></p><p>1、BMQ的架构模式（解决 Kafka 存在的问题）</p><p>2、BMQ读写流程（Failover 机制，写入状态机）</p><p>3、BMQ高级特性（泳道、Databus、Mirror、Index、Parquet）</p><h2 id="消息队列-RocketMQ"><a href="#消息队列-RocketMQ" class="headerlink" title="消息队列 - RocketMQ"></a>消息队列 - RocketMQ</h2><p>使用场景：低延时（电商、订单、库存、物流、秒杀）</p><p>RocketMQ 是阿里巴巴开源的一款消息队列系统，特别适用于 <strong>低延时</strong> 的场景，如 <strong>电商订单</strong>、<strong>库存管理</strong>、<strong>物流调度</strong> 和 <strong>秒杀系统</strong> 等。</p><p><strong>RocketMQ 基本概念</strong></p><ul><li><strong>Queue</strong>：消息队列，RocketMQ 中每个消息都是存储在一个队列中的。</li><li><strong>Tag</strong>：消息标签，用于对消息进行分类和过滤。</li></ul><p><strong>RocketMQ 底层原理</strong></p><p>RocketMQ 采用分布式架构，通过高效的存储模型和传输协议保证低延迟和高吞吐。其底层存储模型支持顺序写入、消息压缩和零拷贝技术。</p><p><strong>RocketMQ 高级特性</strong></p><ol><li><strong>事务消息</strong>：支持事务消息的发送与回滚，用于保证消息的可靠性。</li><li><strong>延迟发送和延迟消息</strong>：允许设置消息的延迟时间，适用于定时任务等场景。</li><li><strong>消费失败和重试</strong>：支持消费失败的消息重试机制，保证消息不丢失。</li><li><strong>死信队列</strong>：当消息无法正常消费时，消息会被投递到死信队列，用于后续的处理和监控。</li></ol><p><strong>小结</strong></p><ol><li><strong>BMQ 架构模式</strong>：通过多机房部署、泳道消息等方式，BMQ 提升了 Kafka 在高并发、高负载场景下的性能。</li><li><strong>BMQ 读写流程</strong>：采用 Failover 机制和写入状态机，保证消息在分布式环境中的可靠传输。</li><li><strong>RocketMQ 高级特性</strong>：支持事务消息、延迟消息、消费重试等功能，非常适合低延迟、高可靠性的场景。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营X豆包MarsCode】第五课-TOS 对象存储实战</title>
      <link href="/2024/11/30/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%BA%94%E8%AF%BE-TOS%20%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2024/11/30/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%BA%94%E8%AF%BE-TOS%20%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="TOS-对象存储实战"><a href="#TOS-对象存储实战" class="headerlink" title="TOS 对象存储实战"></a>TOS 对象存储实战</h1><h2 id="对象存储基本介绍"><a href="#对象存储基本介绍" class="headerlink" title="对象存储基本介绍"></a>对象存储基本介绍</h2><h3 id="抖音背后的存储"><a href="#抖音背后的存储" class="headerlink" title="抖音背后的存储"></a>抖音背后的存储</h3><p>发&#x2F;刷抖音背后有何流程？背后有何种存储需求？</p><p><strong>短视频生产&#x2F;消费</strong></p><p>片源系统–&gt;审核系统–&gt;推送系统</p><p>​<strong>片源系统</strong>：用户上传的原始视频文件。</p><p>​<strong>审核系统</strong>：对视频内容进行审核和检测。</p><p>​<strong>推送系统</strong>：审核通过后，视频被推送至用户推荐流。</p><p><strong>存储需求</strong>：海量、便宜、易用</p><h3 id="为什么对象存储"><a href="#为什么对象存储" class="headerlink" title="为什么对象存储"></a>为什么对象存储</h3><p>为什么需要对象存储呢？</p><p>​<strong>海量数据</strong>：抖音每天生成海量的短视频文件。</p><p>​<strong>高性价比</strong>：存储系统需要具备高效的数据存储能力，同时成本需控制在合理范围内。</p><p>​<strong>易用性</strong>：存储系统需要简单易用，能够高效支持数据上传、下载以及检索等操作。</p><p><strong>存储系统</strong>：单机存储、单机数据库、分布式数据库、分布式存储</p><p>单机存储（单机文件&#x2F;KV）：文件系统、Key-Value 存储</p><p>单机数据库（少量（半）结构化数据）：关系型数据库、非关系型数据库</p><p>分布式数据库（大量（半）结构化数据）：关系型数据库、非关系型数据库</p><p>分布式存储（大数据计算中间结果&#x2F;视频&#x2F;图片）：分布式文件系统、<strong>对象存储</strong></p><p>分布式存储：分布式文件系统HDFS、对象存储TOS</p><p>对象存储TOS更适合短视频生态</p><p><strong>对象存储</strong></p><p>对象：Key（名字）、Meta Data（元信息）、Data（信息）</p><p>适用场景：静态、Immutable（不可变）</p><p>​视频、图片、文件、安装包、备份、前端js文件</p><p>不适用场景：结构化、Mutable</p><p>关系型数据、KV、随机写、Append写、更新频繁</p><h2 id="对象存储使用方法"><a href="#对象存储使用方法" class="headerlink" title="对象存储使用方法"></a>对象存储使用方法</h2><p>对象存储怎么用？</p><p>申请Bucket —&gt;  业务逻辑开发  —&gt; 上线测试</p><p>对象存储对外提供Restful风格的接口</p><p>弱网环境大对象上传，解决方法：MultiUpload（分片上传）</p><p>查看桶里面有哪些对象，解决方法：ListPrefix（分页列举）</p><h2 id="TOS-字节内部实践"><a href="#TOS-字节内部实践" class="headerlink" title="TOS 字节内部实践"></a>TOS 字节内部实践</h2><p>TOS在字节面临的场景有哪些？工程上的解法是？</p><p><strong>容量型</strong>、<strong>QPS型</strong></p><p>容量型</p><p>业务：片源、转码</p><p>特点：容量大、吞吐大、高持久度</p><p>挑战：可扩展性、成本、持久度</p><p>QPS型</p><p>业务：抽帧</p><p>特点：QPS极高</p><p>挑战：可扩展性</p><p>可扩展性解法之<strong>Partitor</strong>（分而治之）</p><p>Q、Hash&#x2F;Range方式优劣？</p><p><strong>Hash分区</strong>：将数据通过哈希函数分配到不同的存储节点，均衡负载，但可能导致数据热点问题。</p><p><strong>Range分区</strong>：按数据范围分配存储，适合某些场景，但可能出现数据不均衡。</p><p>Q、各Partition之间如何负载均衡？</p><p>采用一致性哈希、动态分区等技术实现负载均衡，确保每个节点的存储负载均衡，避免某些节点成为瓶颈。</p><p>持久化解法之<strong>Replication</strong></p><p>Q、Replication的拷贝方式有哪些？</p><p><strong>同步复制</strong>：数据写入时同步复制到多个副本节点，确保数据一致性，但可能带来延迟。</p><p><strong>异步复制</strong>：数据写入后异步复制到副本节点，减少延迟，但在某些情况下可能会丢失数据。</p><p>Q、Replication如何解决一致性问题？</p><p>使用 <strong>一致性协议</strong>（如Paxos、Raft）来保证数据复制的一致性，同时采取 <strong>日志记录</strong> 和 <strong>版本控制</strong> 等方式确保数据的持久性和一致性。</p><p>成本解法之<strong>EC</strong></p><p>Q、当前的EC编码算法有哪些？</p><p>常见的纠删码（Erasure Coding）算法有 <strong>Reed-Solomon编码</strong> 和 <strong>XOR编码</strong>，它们可以通过冗余存储减少存储成本，并提高容错能力。</p><p>Q、多机房的EC如何实现？</p><p>通过将数据分片并存储在不同机房的节点上，即便某个机房发生故障，也能通过其他机房的副本恢复数据。</p><p>成本解法之<strong>温冷转换</strong></p><p>将冷数据转移到性能更差但更廉价的存储介质</p><p><strong>存储需求量细化</strong></p><p>在设计和实现对象存储系统时，需要关注以下几个关键指标：</p><p>​可用性（Availability）</p><ul><li>服务的可靠性，通常通过 <strong>SLA</strong>（服务等级协议）来衡量。</li></ul><p>​数据恢复点目标（RPO）</p><ul><li>指定在系统发生故障后，数据丢失的最大允许时间。</li></ul><p>​数据恢复时间目标（RTO）</p><ul><li>指定在系统故障后，恢复数据和服务所需的最大时间。</li></ul><p><strong>小结</strong></p><p>1、现代互联网应用存在普遍的视频&#x2F;图片等静态内容的海量存储需求</p><p>2、对象存储以其极佳海量存储能力，低廉成本，易用性，称为这类场景的不二之选</p><p>3、对象存储的数据类型：Bucket&#x2F;Object，基本接口Put&#x2F;Get&#x2F;Head&#x2F;Delete，高阶接口MultiUpload&#x2F;ListPrefix</p><p>4、对象存储工程上的挑战和解法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营X豆包MarsCode】第四课-Redis-大厂程序员是怎么用的</title>
      <link href="/2024/11/28/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AF%BE-Redis-%E5%A4%A7%E5%8E%82%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84/"/>
      <url>/2024/11/28/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AF%BE-Redis-%E5%A4%A7%E5%8E%82%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-大厂程序员是怎么用的"><a href="#Redis-大厂程序员是怎么用的" class="headerlink" title="Redis-大厂程序员是怎么用的"></a>Redis-大厂程序员是怎么用的</h1><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>为什么需要Redis，Redis的基本工作原理</p><p><strong>Redis</strong>：开源的、高性能的、支持多种数据结构的Key-Value数据库。不仅是一个缓存系统，还是一个持久化的数据库，能够在内存中高效地进行读写操作。</p><p><strong>背景</strong>：数据量增加、读写数据压力的不断增加（如秒杀、抢购、社交平台的点赞、评论等），传统关系型数据库（如 MySQL）往往无法满足高并发的需求，可能导致响应时间过长、系统崩溃等问题。Redis 的出现提供了一个高效的解决方案。</p><p><strong>高性能读写操作</strong>： Redis 是一个内存数据库，通过内存存储数据，读取速度极快，尤其在处理大量并发请求时表现优异。</p><p><strong>数据持久化</strong>：虽然 Redis 是一个内存数据库，但它支持两种持久化机制：<strong>RDB 快照</strong>和<strong>AOF（追加日志）</strong>。这使得 Redis 即使在系统重启或故障时，也能恢复数据。</p><p><strong>单线程执行</strong>：Redis的命令由单一线程处理，避免了多线程带来的复杂性和性能瓶颈。在单线程下实现高并发处理，避免了多线程并发时可能出现的锁竞争、死锁等问题。虽然单线程看似是性能瓶颈，但 Redis 使用了非常高效的事件驱动机制，能够在一个线程内处理成千上万的请求。</p><p><strong>数据从内存读取</strong>：Redis 的数据是存储在内存中的，所有的读写操作都直接在内存中完成。因此，Redis 的访问速度非常快，能够在毫秒级的时间内完成请求的处理。相对于传统的磁盘数据库（如 MySQL），Redis 的速度更具优势。</p><p><strong>RESP协议</strong>：RESP 协议设计上非常简洁，支持文本和二进制格式，能够在客户端和 Redis 服务器之间高效地传递数据。</p><p><strong>冷热数据分离</strong>：为了提高系统性能，Redis 通常用于缓存热点数据（热数据），例如用户登录信息、商品库存、点赞数等。对于冷数据，则存储在 MySQL 等传统数据库中。这样，Redis 可以加速对热点数据的访问，而数据库则负责存储较少被访问的数据。</p><p><strong>过期时间和内存回收</strong>：Redis 提供了缓存数据的过期策略。你可以为每个键设置过期时间，超过这个时间后，Redis 会自动删除该键值。此外，Redis 还支持多种内存淘汰策略，例如：LRU（最久未使用）、LFU（最不常使用）等，用于在内存满时选择删除哪些数据。</p><h2 id="Redis应用案例"><a href="#Redis应用案例" class="headerlink" title="Redis应用案例"></a>Redis应用案例</h2><p>通过案例，了解Redis的实际应用场景，并介绍Redis常用数据结构</p><p>连续签到，消息通知，计数，排行榜，限流，分布式锁</p><p>这里用到了很多掘金本身的例子来说，这点很不错</p><h3 id="连续签到"><a href="#连续签到" class="headerlink" title="连续签到"></a>连续签到</h3><p>连续签到天数，如果签到中断就会重置</p><p>使用 <strong>String</strong> 数据类型来存储用户的连续签到天数。</p><p>为了避免用户签到次数被重复计算，设置一个过期时间（expireAt），在用户签到到期后重置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Key:用户id</span><br><span class="line">value:252（连续签到天数）</span><br><span class="line">expireAt:后天的0点（过期时间）</span><br></pre></td></tr></table></figure><p>Redis 会通过 <code>INCR</code> 命令对连续签到天数进行递增，同时设置 <code>expireAt</code> 来确保每天签到重置。</p><h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><p>当文章更新时，用户需要接收到推送通知，将更新后的文章推送到 Redis 的 List 中。客户端从 List 中获取消息进行处理。Redis 可以通过消息队列高效地处理这些需求。</p><p>使用 <strong>List</strong> 数据结构来实现消息队列。</p><p>利用 Redis 的 <strong>List</strong> 操作（如 <code>LPUSH</code> 和 <code>BRPOP</code>）来将消息存入队列并通知客户端。</p><p><strong>消息队列</strong>（必考项）</p><p>List数据结构Quicklist，由一个双向链表和listpack实现，支持高效的插入和弹出操作。</p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>很多应用需要对用户的某些操作进行计数。例如，点赞数、访问量、用户行为记录等。这些计数值可能需要存储在一起，以便进行统一管理和查询。</p><p>将多个Key-value存到hash数据结构中</p><p><strong>使用 Pipeline 批量操作</strong>：如果需要对多个计数项进行批量操作，Redis 支持 <strong>Pipeline</strong> 技术，可以将多个命令打包发送到 Redis 服务器，从而减少网络往返的延迟，提升操作效率。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>积分变化时，排名要实时变更</p><p>使用 <strong>ZSet（有序集合）</strong> 数据结构来存储排名信息。</p><p>ZSet 数据结构：zskiplist + dict</p><p><strong>ZSet</strong> 结合了跳跃表和哈希表的特性，通过跳跃表找到元素，再通过dict找到元素的值</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>为了防止系统被大量并发请求压垮，通常需要对某些操作进行限流。</p><p>利用 Redis 的 <strong>String</strong> 类型和 <strong>计时器</strong>（例如时间戳）来实现限流。1s只放行N个，超过限制N则拦截禁止访问</p><p>Key通过当前时间戳进行拼装，Key: API 请求标识 + 时间戳</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Key: API 请求标识 + 时间戳</span><br><span class="line">Value: 请求计数</span><br></pre></td></tr></table></figure><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在高并发的秒杀、抢购等场景，一次只能有一个协程执行Redis 可以通过分布式锁来保证这一点。</p><p>使用 Redis 提供的 <strong>SETNX</strong> 命令（即 Set if Not Exists）来实现分布式锁。</p><p>抢夺锁，完成业务逻辑，释放锁</p><p>redis执行线程是单线程</p><p><strong>存在的问题</strong></p><p>​业务超时问题：当业务执行的时间超过锁的超时时间，可能会导致并发问题。为避免死锁，锁超时后需要重新设置锁的有效期。</p><p>​Redis 主备切换问题：在 Redis 主从复制架构中，当主节点故障时，切换到备节点可能导致临界点问题，尤其是主节点的缓存未及时同步到从节点时。</p><p>​Redis 集群脑裂问题：当 Redis 集群发生网络分区时，可能会出现多个主节点同时处理请求，导致数据不一致的情况。</p><h2 id="Redis使用注意事项"><a href="#Redis使用注意事项" class="headerlink" title="Redis使用注意事项"></a>Redis使用注意事项</h2><p>在字节跳动使用Redis有哪些注意事项</p><h3 id="大Key、热Key"><a href="#大Key、热Key" class="headerlink" title="大Key、热Key"></a>大Key、热Key</h3><p><strong>大 Key</strong>：在 Redis 中，如果某个键的数据量过大，会导致内存占用过多，并且在进行操作时可能会产生性能瓶颈。</p><p>​避免使用大 Key 的方法：拆分、压缩</p><p>​<strong>拆分</strong>：将大数据拆分为多个小 Key，分散存储。</p><p>​<strong>压缩</strong>：对于存储大量数据的 Key，可以进行压缩，以减小内存占用。</p><p><strong>热 Key</strong>：热点数据是频繁被访问的数据，如果某些 Key 被频繁访问，会导致 Redis 在这些 Key 上产生过高的负载，从而影响整体性能。</p><p>​<strong>冷热分离</strong>：将访问频率较高的数据（热数据）缓存到 Redis，而将较少访问的数据（冷数据）存储到数据库（如 MySQL）。如榜单只缓存前10页，后续数据走db</p><p>​<strong>使用 LocalCache</strong>：引入本地缓存（如 Java 的 Guava 或 Golang 的 Bigcache），减少对 Redis 的频繁访问，减轻 Redis 的压力。</p><p>​<strong>Redis 代理</strong>：使用 Redis 代理来发现和处理热 Key，确保 Redis 能承载高频访问的负载。</p><h3 id="慢查询场景"><a href="#慢查询场景" class="headerlink" title="慢查询场景"></a>慢查询场景</h3><p>容易导致redis慢查询的操作</p><p><strong>单批次操作过多的 Key-Value 对</strong></p><p>​使用命令如 <code>MSET</code>、<code>MGET</code>、<code>HMSET</code>、<code>HGETALL</code> 等一次性处理大量数据时，如果操作的数据量非常大，就会对 Redis 服务器造成较大的负担。</p><p><strong>复杂查询操作</strong></p><p>​查询包含大量成员的有序集合（<code>ZSET</code>）或哈希（<code>HASH</code>）时，如果数据量非常大，Redis 需要消耗较长时间来计算排名、排序等。</p><p><strong>长时间阻塞操作</strong></p><p>​一些 Redis 命令可能会在执行期间阻塞当前线程，特别是涉及到大数据量的操作时。这会导致其他客户端的请求排队，增加延迟。</p><h3 id="缓存穿透、缓存雪崩（必考）"><a href="#缓存穿透、缓存雪崩（必考）" class="headerlink" title="缓存穿透、缓存雪崩（必考）"></a>缓存穿透、缓存雪崩（必考）</h3><p><strong>缓存穿透</strong>：热点数据查询绕过缓存，直接查询数据库</p><p>​查询不存在的数据的查询请求会直接打到db</p><p>​热Key过期会有大量请求击穿至db</p><p>​如何减少缓存穿透：缓存空值，布隆过滤器</p><p><strong>缓存雪崩</strong>：大量缓存同时过期</p><p>​如何避免缓存雪崩：</p><p>​缓存空值，将缓存失效时间反散开</p><p>​使用缓存集群</p><p><strong>小结</strong></p><ul><li><strong>大 Key 和热 Key</strong>：通过拆分、压缩和冷热分离来优化内存使用，并引入本地缓存减少对 Redis 的访问压力。</li><li><strong>慢查询</strong>：避免在单次操作中使用过多的键值对，合理拆分批量操作，避免对 Redis 产生过大负担。</li><li><strong>缓存穿透和缓存雪崩</strong>：通过缓存空值、使用布隆过滤器以及反散列过期时间等手段来降低这些问题的发生概率，保证系统的稳定性。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营X豆包MarsCode】第三课-带你认识存储 &amp; 数据库</title>
      <link href="/2024/11/28/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%B8%89%E8%AF%BE-%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8%20&amp;%20%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/11/28/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%B8%89%E8%AF%BE-%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8%20&amp;%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="带你认识存储-数据库"><a href="#带你认识存储-数据库" class="headerlink" title="带你认识存储 &amp; 数据库"></a>带你认识存储 &amp; 数据库</h1><h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><p>一条数据从产生，到数据流动，最后持久化的全生命周期</p><p>用户脑子 &#x3D;》 后端服务器 &#x3D;》 数据库 （《&#x3D;》其他系统）</p><p>数据的持久化</p><p>注册“小明”，检查是否存在（合法性），用数据架构组织数据（修改内存），写入硬件（写入存储介质）</p><p>潜在问题</p><p>Q、数据库怎么保证数据不丢？</p><p>​数据库通常使用事务日志和多副本存储来保证数据可靠性。即使发生故障，也能通过日志恢复数据。</p><p>Q、数据库怎么处理多人同时修改的问题？</p><p>​数据库通过事务的<strong>隔离性</strong>和<strong>锁机制</strong>来确保并发访问的正确性。</p><p>Q、为什么用数据库，除了数据库还能存到别的存储系统吗？</p><p>​数据库提供更强的数据管理能力（如事务、索引、高效查询），但对于特定场景，也可以使用文件系统、分布式存储等替代。</p><p>Q、数据库只能处理结构化数据吗？</p><p>​不是，关系型数据库擅长处理结构化数据，而非关系型数据库可以处理半结构化或非结构化数据（如JSON、图像）。</p><p>Q、有哪些操作数据库的方式，要用什么编程语言？</p><p>​常用<strong>SQL</strong>操作关系型数据库，或使用数据库的SDK（Java、Python、Go等）与其交互；非关系型数据库通常提供RESTful API或自定义协议。</p><h2 id="存储-数据库简介"><a href="#存储-数据库简介" class="headerlink" title="存储 &amp; 数据库简介"></a>存储 &amp; 数据库简介</h2><p>数据库和存储系统背景知识，它们是什么，有哪些特点？</p><p>用户、硬件、内存、网络</p><p>性能要求高、代码简单又复杂、容易受硬件影响</p><p>性能要求高：后端软件的底座</p><p>代码简单又复杂：考虑到软件硬件可能会出错各种异常情况</p><p>易受硬件影响：软件顺应硬件的变革而变</p><p><strong>存储器层级结构</strong></p><p>存储器：容量、读取速度</p><p>数据怎么从应用到存储介质</p><p>【缓存】很重要，贯穿整个存储体系</p><p>【拷贝】很昂贵，应该尽量减少</p><p>需要有抽象统一的接口层</p><p>RAID技术用于存储系统的容错和性能优化</p><p>存储系统和数据库的区别</p><p><strong>存储系统</strong>：关注数据的存储与检索，如文件系统、分布式存储。</p><p><strong>数据库</strong>：强调数据管理与关系处理，支持复杂的查询和事务。</p><p><strong>ACID</strong></p><p>原子性、一致性、隔离性、持久性</p><ul><li><strong>原子性</strong>：事务要么完全完成，要么完全失败。</li><li><strong>一致性</strong>：事务结束后，数据库从一个一致状态转到另一个一致状态。</li><li><strong>隔离性</strong>：并发事务互不干扰。</li><li><strong>持久性</strong>：事务提交后，数据永久存储。</li></ul><h2 id="主流产品剖析"><a href="#主流产品剖析" class="headerlink" title="主流产品剖析"></a>主流产品剖析</h2><p>主流的存储 &amp; 数据库系统架构，经典产品剖析</p><h3 id="单机存储"><a href="#单机存储" class="headerlink" title="单机存储"></a>单机存储</h3><p><strong>本地文件系统</strong></p><ul><li>Linux哲学“一切皆文件”，通过索引节点（Index Node）和目录项（Directory Entry）组织数据。</li></ul><p><strong>Key-Value存储</strong></p><ul><li>采用LSM-Tree结构优化写入性能，如LevelDB。</li></ul><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>在单机存储基础上实现分布式协议，涉及网络交互</p><ul><li><strong>HDFS</strong>：Master-Slave架构，适合大文件存储。</li><li><strong>Ceph</strong>：分布式对象存储，支持块存储和文件系统。</li></ul><h3 id="单机关系型数据库"><a href="#单机关系型数据库" class="headerlink" title="单机关系型数据库"></a>单机关系型数据库</h3><p><strong>Oracle</strong>：企业级数据库，功能强大但成本高。</p><p><strong>MySQL</strong>：开源数据库，易用且性能优良。</p><p><strong>PostgreSQL</strong>：支持复杂查询和扩展功能。</p><h3 id="单机非关系型数据库"><a href="#单机非关系型数据库" class="headerlink" title="单机非关系型数据库"></a>单机非关系型数据库</h3><p><strong>MongoDB</strong>：文档型数据库，灵活处理JSON数据。</p><p><strong>Redis</strong>：高性能Key-Value数据库，支持缓存和持久化。</p><p><strong>Elasticsearch</strong>：全文检索数据库，适合处理日志数据和搜索需求。</p><p>交互方式各不相同</p><p>scheme相对灵活</p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>解决单机容量和性能限制问题</p><p>容量、弹性、性价比</p><p>TiDB、CockroachDB</p><h2 id="新技术演进"><a href="#新技术演进" class="headerlink" title="新技术演进"></a>新技术演进</h2><p>老系统结合新技术，如何持续演进走向新生？</p><p><strong>硬件革命</strong>：</p><ul><li>NVM（非易失性存储器）：结合DRAM和SSD的优势。</li><li>SPDK（存储性能开发工具包）：高性能存储访问优化技术。</li></ul><p><strong>AI增强</strong>：</p><ul><li>智能查询优化器、数据分析加速器。</li></ul><p><strong>软件架构变革</strong>：</p><ul><li>从单体架构到微服务、Serverless等现代架构。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营X豆包MarsCode】第二课-深入浅出RPC框架</title>
      <link href="/2024/11/25/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AF%BE-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/11/25/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AF%BE-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="深入浅出-RPC-框架"><a href="#深入浅出-RPC-框架" class="headerlink" title="深入浅出 RPC 框架"></a>深入浅出 RPC 框架</h1><h2 id="RPC-框架分层设计"><a href="#RPC-框架分层设计" class="headerlink" title="RPC 框架分层设计"></a>RPC 框架分层设计</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>RPC （Remote procedure call 远程函数调用）是一种通过网络调用远程服务的方法，使程序可以像调用本地函数一样调用分布式系统中位于远程服务器上的函数。</p><p><strong>函数映射</strong>、<strong>数据转换成字节流</strong>、<strong>网络传输</strong></p><p><strong>函数映射</strong></p><p>在客户端调用一个远程函数时，如何将该调用正确映射到服务端对应的函数</p><p>服务注册，函数唯一标识符id，接口定义语言（IDL）</p><p>本地和远程是不同的进程，不共享内存</p><p><strong>数据转换成字节流</strong></p><p>将函数的参数和返回值序列化为可以通过网络传输的字节流格式</p><p><strong>序列化</strong>（Serialization）：将参数和返回值转换为字节流。</p><ul><li>常用格式：JSON、XML（文本格式，易读但较慢）；Protocol Buffers、Thrift、Avro（二进制格式，高效但不易读）。</li></ul><p><strong>反序列化</strong>（Deserialization）：将接收到的字节流还原为原始数据。</p><p>序列化工具：</p><ul><li><strong>JSON</strong>：简单易用，语言无关，但性能不高。</li><li><strong>Protocol Buffers（Protobuf）</strong>：高效二进制序列化，适合高性能 RPC。</li><li><strong>Thrift</strong>：序列化与 RPC 框架结合，支持多语言。</li></ul><p><strong>网络传输</strong></p><p>负责将序列化后的字节流在客户端与服务端之间传输</p><p><strong>IDL</strong>—平台之间通信的统一规范接口</p><p>IDL（Interface description language）</p><p>一种描述接口（包括方法和数据结构）的语言，用于定义客户端与服务端之间的通信协议。它抽象出服务的接口定义，并支持跨语言的实现，使客户端和服务端能够通过生成代码来实现一致的交互</p><p>IDL声明自己的方法，参数，按照约定调用</p><p>双方共用一套IDL，可以利用工具生成代码</p><p><strong>微服务</strong></p><p>一种软件架构风格，它将一个大型的应用程序拆分为多个独立的、松耦合的服务，每个服务专注于实现单一业务功能。微服务架构的核心思想是将应用程序划分为独立运行的小服务，这些服务可以单独开发、部署和扩展</p><p>好处</p><p>单一职责，分工协作，便于运维开发</p><p>可扩展性强、灵活性、故障隔离</p><p>弊端</p><p>网络消息可达性、开发复杂度增加、运维成本高</p><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p><strong>RPC框架</strong></p><p>微服务的问题将由RPC框架解决，通过框架的工具化和标准化减少了开发和运维中的复杂度</p><p>网络通信层、协议层、编解码层</p><p><strong>编解码层</strong></p><p>负责将数据转换为适合网络传输的格式（序列化）以及从网络数据中恢复原始数据（反序列化）</p><p>生成代码，同一份IDL文件生成对应不同语言的版本</p><p>数据格式：语言特定的格式、文本格式、二进制编码</p><p>语言特定的格式：编程语言内建支持将内存对象编码为字节序列</p><p>文本格式：JSON、XML、CSV，人类可读</p><p>二进制编码：跨语言，高性能 Thrift、Protobuf</p><p>编码格式的选型（需要考量的因素）</p><p>兼容性、通用性、性能</p><p>兼容性：自动增加新的字段，不影响老的服务</p><p>通用性：跨平台跨语言</p><p>性能：空间（编码后数据大小）、时间（编码时长）</p><p><strong>协议层</strong></p><p>定义客户端与服务端之间数据传输的规则，解决如何区分和解析协议单元的问题</p><p>如何区分各个协议单元：<strong>特殊结束符</strong>、<strong>变长协议</strong></p><p>特殊结束符：特殊字符表示结束</p><p>​HTTP协议头是以 回车+换行 结束</p><p>变长协议：定长+不定长，定长描述不定长长度</p><p>​header+body</p><p>协议解析</p><p><strong>网络通信层</strong></p><p>底层负责数据的传输，通常使用操作系统提供的 <strong>Sockets API</strong> 直接管理网络通信</p><p>负责在客户端与服务端之间建立连接、发送数据包、接收响应</p><p>创建 socket 对象（支持 TCP&#x2F;UDP 协议），绑定地址和端口，监听、发送和接收数据。</p><p><strong>网络库</strong></p><p>在 Sockets API 基础上进一步封装，提供易用性、功能性和性能优化的网络通信功能</p><p>提供易用API、功能、性能</p><h2 id="关键指标分析与企业实践"><a href="#关键指标分析与企业实践" class="headerlink" title="关键指标分析与企业实践"></a>关键指标分析与企业实践</h2><h3 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h3><p>稳定性、易用性、扩展性、观测性、高性能</p><p><strong>稳定性</strong></p><p>熔断、限流、超时控制</p><p>请求成功率：负载均衡、重试</p><p>长尾请求：备份请求</p><p>实际解决-注册中间件</p><p><strong>易用性</strong></p><p>开箱即用、周边工具</p><p>开箱即用：合理的默认参数、丰富的文档</p><p>周边工具：生成代码工具、脚手架工具</p><p><strong>扩展性</strong></p><p>Middleware、Option、编解码层、协议层、网络传输层、代码生成工具插件扩展</p><p><strong>观测性</strong></p><p>传统三件套：Log、Metric、Tracing</p><p>Log日志</p><p>Metric监控：监控面板</p><p>Tracing<strong>链路跟踪</strong>：层层请求的耗时，通过一个id把一层层串起来</p><p><strong>高性能</strong></p><p>高吞吐低延迟</p><h3 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h3><p><strong>Kitex</strong></p><p>自研网络库</p><p>原生库连接池中存在失效连接，存在goroutine暴涨的风险</p><p>合并部署：将亲和性强的服务实例调度到同一个物理机，远程RPC调用优化为本地IPC调用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【青训营X豆包MarsCode】第一课-Go 语言基础语法</title>
      <link href="/2024/11/03/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%B8%80%E8%AF%BE-Go%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/11/03/%E3%80%90%E9%9D%92%E8%AE%AD%E8%90%A5X%E8%B1%86%E5%8C%85MarsCode%E3%80%91%E7%AC%AC%E4%B8%80%E8%AF%BE-Go%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-语言基础语法"><a href="#Go-语言基础语法" class="headerlink" title="Go 语言基础语法"></a>Go 语言基础语法</h1><h2 id="走进-Go-语言基础语法"><a href="#走进-Go-语言基础语法" class="headerlink" title="走进 Go 语言基础语法"></a>走进 Go 语言基础语法</h2><h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><p>时间相关的函数，以及时间的格式化</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(t)</span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="数字解析"><a href="#数字解析" class="headerlink" title="数字解析"></a>数字解析</h3><p>将字符串转成int：strconv.ParseInt(字符串，进制，精度位数) 或者 strconv.Atoi(字符串)（自动识别）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line">n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">fmt.Println(n2) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><p>当我们在命令行中输入 go run example&#x2F;20-env&#x2F;main.go a b c d 时，os.Args可以获取到输入的参数 a b c d。</p><p>fmt.Println(os.Getenv(“PATH”))打印了环境变量 PATH 的值，它通常包含了一系列目录，用于指定在执行命令时搜索可执行文件的路径。</p><p>fmt.Println(os.Setenv(“AA”, “BB”))设置了一个名为 AA 的环境变量，其值为 BB。如果设置成功，它不会返回任何错误，即返回 nil。如果设置失败，比如内存不足或者其他系统错误，它会返回一个非 nil 的错误对象。</p><p>使用 exec.Command 函数执行了一个外部命令，即使用 grep 命令在 &#x2F;etc&#x2F;hosts 文件中搜索包含 127.0.0.1 的行。如果命令执行成功，它会打印出搜索到的行；如果执行失败，它会抛出一个 panic。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(os.Args)</span><br><span class="line">fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>))</span><br><span class="line">fmt.Println(os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>)) <span class="comment">//nil</span></span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;AA&quot;</span>)) <span class="comment">//BB</span></span><br><span class="line">    </span><br><span class="line">buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// 127.0.0.1 localhost</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h3><p>序列化和反序列化</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Age   <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">Hobby []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">a := userInfo&#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;TypeScript&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line">buf, err := json.Marshal(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">err = json.Unmarshal(buf, &amp;b)</span><br></pre></td></tr></table></figure><p>小技巧：鼠标悬浮在函数上，可以看到链接，可以跳转过去，非常的方便</p><h2 id="Go-语言的实战案例"><a href="#Go-语言的实战案例" class="headerlink" title="Go 语言的实战案例"></a>Go 语言的实战案例</h2><h3 id="猜谜游戏"><a href="#猜谜游戏" class="headerlink" title="猜谜游戏"></a>猜谜游戏</h3><p>猜谜游戏是一个很简单的小游戏，但是我们可以将这个小游戏才往下拆分成更小的模块，这也是重要的编程思想——大事化小，小事化了</p><p>猜谜游戏可以再拆分成<strong>随机数模块</strong>、<strong>输入模块</strong>、<strong>比较模块</strong></p><p>先是<strong>随机数模块</strong></p><p>直接使用rand.Intn(maxNum)会是伪随机数，一般情况下需要使用每次运行的时间戳初始化种子，但是没有设置种子的实际运行下每次运行的数都不一样，搜索得知在 Go 1.20 及更高版本中，程序会默认使用一个隐式的随机数生成器，可能会导致每次运行时生成不同的随机数。这是因为默认的随机数生成器会基于时间等因素来生成随机数，也就是说，在高版本中，优化了这个问题。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxNum := <span class="number">100</span></span><br><span class="line">secretNumber := rand.Intn(maxNum)</span><br><span class="line">fmt.Println(<span class="string">&quot;The secret number is &quot;</span>, secretNumber)</span><br><span class="line"></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">secretNumber := rand.Intn(maxNum)</span><br><span class="line">fmt.Println(<span class="string">&quot;The secret number is &quot;</span>, secretNumber)</span><br></pre></td></tr></table></figure><p>接下来是<strong>输入模块</strong></p><p>这里采用的是bufio包，进行输入的处理</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Please input your guess&quot;</span>)</span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;An error occured while reading input. Please try again&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">input = strings.Trim(input, <span class="string">&quot;\r\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>不过明显直接使用Scan明明简洁多了，这种方法和直接Scan，毕竟两者的复杂性差太多了</p><p>后面有解释道这个包以后会用到，所以就采用相对曲折的方式，想想也是，曲折说明比较底层，相对来说可以自定义的空间就大，可适用场景就多</p><p>比较模块什么说的</p><h3 id="在线词典"><a href="#在线词典" class="headerlink" title="在线词典"></a>在线词典</h3><p>在线词典拆解一下，就是<strong>调用API</strong>、<strong>JSON格式化</strong>、<strong>提取信息</strong></p><p><strong>调用第三方API</strong></p><p>输入：单词 ——-&gt;  输出：音标词义</p><p>需要了解request和response的结构</p><p>HTTP请求的结构：请求行、请求头、请求体</p><p>JSON的部分属于请求体的模块</p><p>在页面中输入单词进行翻译，在开发者工具中就可以看到新的request，找到它（注意是POST）</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    trans_type<span class="punctuation">:</span> <span class="string">&quot;en2zh&quot;</span><span class="punctuation">,</span> <span class="comment">//英译中</span></span><br><span class="line">    source<span class="punctuation">:</span> <span class="string">&quot;good&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    user_id<span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再看response，可以看到JSON结构，直接在开发者工具中Copy-Copy as cURL(cmd)，将复制下来的东西粘贴到终端中运行就可以得到网站的返回JSON</p><p>之后找一个代码自动生成的网站，将之前复制下来的东西直接丢进去，它就会自动生成响应的代码，粘贴到编译器里，就可以访问网站返回json数据</p><p><strong>JSON格式化</strong></p><p>request和response在收发过程中需要JSON序列化和反序列化</p><p>序列化是将一个数据结构（如结构体、对象、数组等）转换为字符串（通常是 JSON 格式）的过程。这使得数据能够以文本形式进行存储或传输。</p><p>JSON格式化没有想象中那么复杂</p><p>那么对应的API文档一个是怎么样的？</p><p><strong>API 文档示例</strong></p><p>关于API，这里想要展开一下</p><ol><li>概述</li></ol><p>该 API 提供了一个词典查询服务，可以将英文单词翻译成中文并返回相关信息。</p><ol start="2"><li>基本信息</li></ol><ul><li><strong>API Endpoint</strong>: <code>POST https://api.interpreter.caiyunai.com/v1/dict</code></li><li><strong>请求格式</strong>: JSON</li><li><strong>响应格式</strong>: JSON</li></ul><ol start="3"><li>请求参数</li></ol><p>请求体需要为 JSON 格式，包含以下字段：</p><table><thead><tr><th>字段</th><th>类型</th><th>必填</th><th>描述</th></tr></thead><tbody><tr><td>trans_type</td><td>string</td><td>是</td><td>翻译类型，固定值为 <code>&quot;en2zh&quot;</code></td></tr><tr><td>source</td><td>string</td><td>是</td><td>待翻译的英文单词</td></tr><tr><td>user_id</td><td>string</td><td>是</td><td>用户 ID，用于标识请求用户</td></tr></tbody></table><p><strong>示例请求体</strong>:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;trans_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;en2zh&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;good&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>请求头</li></ol><p>需要设置以下请求头：</p><table><thead><tr><th>请求头</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Content-Type</td><td>string</td><td>请求体类型，固定为 <code>application/json;charset=UTF-8</code></td></tr><tr><td>User-Agent</td><td>string</td><td>客户端信息</td></tr><tr><td>X-Authorization</td><td>string</td><td>访问令牌</td></tr><tr><td>Accept</td><td>string</td><td>接受的响应格式，通常为 <code>application/json</code></td></tr></tbody></table><ol start="5"><li>响应参数</li></ol><p>响应体为 JSON 格式，包含以下字段：</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>rc</td><td>int</td><td>响应状态码，0表示成功</td></tr><tr><td>wiki</td><td>object</td><td>相关的维基信息，包括翻译描述和图片链接</td></tr><tr><td>dictionary</td><td>object</td><td>包含单词发音、解释、同义词、反义词等信息</td></tr></tbody></table><p><strong>提取信息</strong></p><p>对于接收到的数据，我们需要从中提取出我们想要的数据，在这里就是单词的音标和释义</p><p>首先，我们定义一个与 JSON 数据结构匹配的 Go 结构体，该结构体的字段应该与 JSON 中的键相对应，并且要使用 JSON 标签来指定映射关系。</p><p>可以直接访问结构体的字段来提取所需的信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(word, <span class="string">&quot;UK:&quot;</span>, dictResponse.Dictionary.Prons.En, <span class="string">&quot;US:&quot;</span>, dictResponse.Dictionary.Prons.EnUs)</span><br></pre></td></tr></table></figure><p>到这里我们已经实现了调用第三方API实现翻译的功能</p><p>即输入单词，输出单词音标和释义</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run 文件路径 beautiful</span><br><span class="line">beautiful UK: [ˈbjuːtəful] US: [ˈbjutəfəl]</span><br><span class="line">a.美丽的;优美的;完美的;完善的;美好的;高明的;很棒的</span><br><span class="line">n.美丽的东西;美人</span><br></pre></td></tr></table></figure><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>—SOCKS5</p><p>SOCKS5原理：协商、认证、请求、relay 四个阶段</p><p>协商：浏览器向代理说明自己支持的认证方式，然后代理从中选择一个自己支持的返回给浏览器</p><p>认证：（跳过）因为此处实现不加密的代理</p><p>请求：浏览器向代理发送collection请求，命令代理和某个IP端口建立连接</p><p>relay：浏览器正常发送请求，代理转发请求给真正服务器，服务器返回响应，代理也转发响应给浏览器，在转发过程中代理不注意流量的细节</p><p><strong>TCP echo server</strong></p><p>先做一个简单的 TCP echo server</p><p>客户端向服务器发送什么，服务器都会返回一样的数据</p><p>显示监听自己的本机端口，看看有没有客户端访问，如果有就存储在client里，给每个访问的客户端都分配一个单独的进程（或者不叫进程），总之这里应该涉及并发，也是能够体现Go语言特性和优势的地方，这里是一个典型的S&#x2F;C模式</p><p>讲到这里会启动一个go-routine</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1080&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">client, err := server.Accept() </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Accept failed %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(client) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么goroutine是什么？</p><p>简单来说，goroutine是Go特色一种智能管理的、方便简洁的协程，也是Go天然支持高并发的主要条件</p><p>接下来就是逐步实现SOCKS5的四个阶段 协商、认证、请求、relay </p><p><strong>协商+认证阶段</strong></p><p>认证方法 authenticate（用户，程序）验证身份</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>简单来说，就是客户端向服务器发出请求，某协议，支持的认证方式，然后服务器从中选择支持的认证方式</p><p><strong>请求阶段</strong></p><p>浏览器发送报文：版本、请求类型、ATYP目标地址类型、地址、目标端口</p><p>ATYP 的使用允许代理服务器灵活地处理不同类型的地址，因此在实现 SOCKS 代理或其他网络协议时，理解 ATYP 的含义非常重要。</p><p><strong>relay阶段</strong></p><p>代理服务器也已经跑通了，但是代理服务器的输出中的有个addr的输出有点在意，按理来说addr应该是目标地址，但是我换终端执行addr居然也会变，这简直就像是addr是终端的地址一样，但是这不太对。</p><p>于是我打算进行调试，既然要调试，那么就把项目代码拷贝到本地，我认为这是必要的一步</p><p>最后在调试中发现代理接收到的ATYP（目标服务器地址类型）是IPv4，而不是域名，但是我发送的命令是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://qq.com</span><br></pre></td></tr></table></figure><p>也就是说客户端在curl中就把域名解析成IP地址了，应该是使用的本地DNS服务器</p><p>而为什么IP地址会不断变化呢，而且是随着终端的终端的变化而变化，为了验证以上前提，先进行一步检验</p><p>本地的不同终端似乎没有出现这种现象，只有云端的会出现</p><p>Q、不同终端访问qq.com网址使用的IP会不同吗？</p><p>A：是的，不同终端访问同一个网址（如 qq.com）时，使用的 IP 地址可能会不同。这主要受到以下几个因素的影响：</p><ol><li><strong>DNS 解析</strong>：当你访问一个网址时，首先会通过 DNS（域名系统）将域名解析为 IP 地址。不同的 DNS 服务器可能返回不同的 IP 地址，尤其是对于大型网站，它们可能有多个服务器并采用负载均衡技术。</li><li><strong>地理位置</strong>：某些网站可能会根据用户的地理位置返回不同的 IP 地址，以便提供更快的访问速度或更好的内容分发。例如，访问 qq.com 的用户如果在中国大陆，可能会解析到与在海外用户不同的 IP 地址。</li><li><strong>网络环境</strong>：不同的网络环境（如家庭 Wi-Fi、移动网络等）可能使用不同的出口 IP 地址。在同一个网络下，不同的设备通常会共享同一个公网 IP 地址，但如果网络使用了 NAT（网络地址转换），内部设备的访问可能被不同的网络策略影响。</li><li><strong>动态 IP 地址</strong>：某些 Internet 服务提供商（ISP）使用动态 IP 地址分配，因此同一用户在不同时间连接互联网时，可能会获得不同的 IP 地址。</li></ol><p>探究到这里告一段落，先把课程看完</p><p>课程的最后，正如前面所说，讲了如何配置proxy，就只需要安装一个 Proxy SwichyOmega 即可，在 Proxy SwichyOmega 中配置代理服务器的地址，也就是说讲浏览器连接到代理服务器，由代理服务器全权负责我们 访问目标服务器的动作</p><p>到这里感觉，代理，就是一台主机请另一台主机帮忙访问，相当于请同学用他自己的电脑帮我访问我想要访问的网站，他访问之后得到的数据给我，就这样而已，由于是他访问，所以那端的服务器当然看到访问的IP地址是同学的IP地址，不会知道我的存在，就是一个这么简单的过程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu双系统安装</title>
      <link href="/2024/10/31/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>/2024/10/31/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu双系统安装"><a href="#Ubuntu双系统安装" class="headerlink" title="Ubuntu双系统安装"></a>Ubuntu双系统安装</h1><p>鉴于Linux在的种种便利，最近打算装一个Ubuntu，虽然之前使用VMware装过Ubuntu的虚拟机，但是由于未知原因（可能是内存不够，同时运行Windows和Ubuntu比较吃力），我的Ubuntu虚拟机运行得比较卡顿，于是想干脆装个双系统好了。</p><p>准备材料：U盘（最好8G以上，不要有文件，到时候需要格式化，文件会损坏）</p><p>省流：将U盘作为Ubuntu启动盘，在空余的磁盘空间安装Ubuntu系统</p><p>安装过程如下</p><h2 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h2><p>下载Ubuntu.iso文件</p><p>官网：<a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p><p>镜像网：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/</a></p><p>选择合适的版本，注意选择 标记LTS 的版本，表示长期支持（比如<strong>24.04</strong>，<strong>22.04</strong>之类的）</p><p>下载写入工具（比如rufus、win32diskImager），这里使用win32diskImager</p><p>下载地址：<a href="https://sourceforge.net/projects/win32diskimager/">https://sourceforge.net/projects/win32diskimager/</a></p><p>选择U盘，写入Ubuntu.iso文件</p><p>然后格式化U盘</p><h2 id="腾出磁盘空间"><a href="#腾出磁盘空间" class="headerlink" title="腾出磁盘空间"></a>腾出磁盘空间</h2><p>在磁盘管理（Windows+X可以看到）中，如果看到磁盘没有空余的磁盘空间（黑色），那么就压缩现有的分区，腾出磁盘空间，留给Ubuntu系统使用</p><p>由于安装的是双系统，Ubuntu会自动识别磁盘中空余的位置，也就是压缩卷预留出来的磁盘空间</p><h2 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>进入BIOS（不同品牌不同型号的电脑进入界面的方式不同，大部分可能是重启电脑狂按F2，也有些可以按特殊的小孔按钮进入），在BIOS界面中将启动盘对应的选项设置为Enable</p><p>Q、BIOS界面是什么？</p><p>A：BIOS（Basic Input&#x2F;Output System）是计算机的一种固件，用于在计算机开机时初始化硬件并引导操作系统。BIOS界面通常是一个文本模式的界面，允许用户配置系统设置，如启动顺序、硬件配置、日期和时间等。BIOS界面可以引导设备选择，允许用户选择从哪个设备（如硬盘、USB驱动器或光盘）启动操作系统。</p><p>然后再按F2，进入启动设备界面，就可以看到Ubuntu选项</p><p>进入Ubuntu，就可以进入Ubuntu安装配置界面</p><p>安装完成。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【7天用Go从零实现】Web框架Gee教程(2)</title>
      <link href="/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="7天用Go从零实现Web框架Gee教程（2）"><a href="#7天用Go从零实现Web框架Gee教程（2）" class="headerlink" title="7天用Go从零实现Web框架Gee教程（2）"></a>7天用Go从零实现Web框架Gee教程（2）</h1><p>本文参考：<a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html</a></p><p>好的，让我们继续往下看</p><h2 id="Day2-上下文"><a href="#Day2-上下文" class="headerlink" title="Day2 上下文"></a>Day2 上下文</h2><p>先看看文件结构吧</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">│  <span class="keyword">go</span>.mod</span><br><span class="line">│  main.<span class="keyword">go</span></span><br><span class="line">│</span><br><span class="line">└─gee</span><br><span class="line">        context.<span class="keyword">go</span></span><br><span class="line">        gee.<span class="keyword">go</span></span><br><span class="line">        <span class="keyword">go</span>.mod</span><br><span class="line">        router.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>这里是对gee框架进一步拆解模块化，分为context，gee，router，重点看看context，就是其实就是将Request和Response进行了封装，顶多将常用的Path、Method、StatusCode拎出来了而已， 噢，还有内部的方法，写响应的String、JSON、Data、HTML各种格式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// origin objects</span></span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"><span class="comment">// request info</span></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line"><span class="comment">// response info</span></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router是关于路由映射的一些方法（废话x，而gee中只是对这些方法进行简单的调用，一开始还觉得有点多此一举的，不过这是为了框架的清晰划分</p><h2 id="Day3-前缀树路由"><a href="#Day3-前缀树路由" class="headerlink" title="Day3 前缀树路由"></a>Day3 前缀树路由</h2><p>老规矩，先看看文件结构</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">│  <span class="keyword">go</span>.mod</span><br><span class="line">│  main.<span class="keyword">go</span></span><br><span class="line">│</span><br><span class="line">└─gee</span><br><span class="line">        context.<span class="keyword">go</span></span><br><span class="line">        gee.<span class="keyword">go</span></span><br><span class="line">        <span class="keyword">go</span>.mod</span><br><span class="line">        router.<span class="keyword">go</span></span><br><span class="line">        router_test.<span class="keyword">go</span></span><br><span class="line">        trie.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺带一提，tree /f查看文件结构</span></span><br></pre></td></tr></table></figure><p>在之前的基础上增加了trie文件和router_test文件</p><p>从文章标题就知道路由的增强是重头戏，这里通过trie树的数据结构对路由进行了加强，实现了动态路由，trie文件就是trie树算法的文件，还有就是router_test这个文件，出现了单元测试的概念，有所耳闻，当初看到的时候很兴奋，看了看是在文件中设置了一些预设，以便进行测试，还有就是router_test文件的图标都是不一样的，看来在Goland看来router_test文件是比较独特的，对于单元测试这一块就放到下一次再写好了，因为现在我也没搞懂，停下来写博客只是因为思路比较混乱，现在好多了（滑稽），前面就是未知领域了，等我先研究研究</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【7天用Go从零实现】Web框架Gee教程(1)</title>
      <link href="/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2024/09/19/7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="7天用Go从零实现Web框架Gee教程-1"><a href="#7天用Go从零实现Web框架Gee教程-1" class="headerlink" title="7天用Go从零实现Web框架Gee教程(1)"></a>7天用Go从零实现Web框架Gee教程(1)</h1><p>本文参考：<a href="https://geektutu.com/post/gee.html">https://geektutu.com/post/gee.html</a></p><p>研究这个教程的时候，我刚刚开始学习用Go，觉得单纯看语法学习效率较低，而且容易遗忘，所以就打算边看边学，顺便学习Web框架相关的知识，之前用过爬虫，但还只是浅尝辄止，稀里糊涂，我想学习Web框架也有助于对爬虫的理解。</p><p>对于初步使用Go语言搭建Web应用的人来说，Gin框架无疑是最常见的，我也不例外，之前也用Gin写了一个简单的TODOList， 而Gee框架是一个简化的类Gin框架，适合帮助初学者理解Web框架。</p><p>写这篇博客的时候我已经看到了Day3，到Day3的时候项目已经逐渐变得稍微复杂起来，而且出现了单测这个之前有所耳闻的概念，脑子里有些混乱了，于是打算停下来复盘一下，顺便写篇博客。</p><h2 id="Day0-序言"><a href="#Day0-序言" class="headerlink" title="Day0  序言"></a>Day0  序言</h2><p>框架有简化开发的作用，避免了不必要的繁复操作，同时框架提供了很多额外的功能，像是动态路由、中间件等等</p><h2 id="Day1-HTTP基础"><a href="#Day1-HTTP基础" class="headerlink" title="Day1 HTTP基础"></a>Day1 HTTP基础</h2><p>这篇包括了三个Web应用版本，由最基础逐渐复杂起来（虽然整个教程就是这样一个常见的“合理的”难度梯度）</p><h3 id="base1"><a href="#base1" class="headerlink" title="base1"></a>base1</h3><p>这里主要就是要了解net&#x2F;http标准库中的HandleFunc和ListenAndServe两个函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// day1-http-base/base1/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes r.URL.Path</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes r.URL.Header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenAndServe这个函数是比较简单的，看看ListenAndServe的源码好了</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建一个 TCP 监听器  </span></span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 确保在退出时关闭监听器  </span></span><br><span class="line">    <span class="keyword">defer</span> listener.Close()  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有提供处理器，使用 DefaultServeMux  </span></span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;  </span><br><span class="line">        handler = DefaultServeMux  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入接受连接的循环  </span></span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        <span class="comment">// 接受连接  </span></span><br><span class="line">        conn, err := listener.Accept()  </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">            <span class="comment">// 处理错误  </span></span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个连接启用一个新的 goroutine  </span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">            <span class="keyword">defer</span> conn.Close() <span class="comment">// 确保连接在处理完后关闭  </span></span><br><span class="line">            <span class="comment">// 处理请求的逻辑  </span></span><br><span class="line">            <span class="comment">// 这包括读请求、调用处理器、写回响应等  </span></span><br><span class="line">            handler.ServeHTTP(conn, ...)  </span><br><span class="line">        &#125;()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数是监听的端口号，第二个参数则是处理器Handler，Handler当然也是http库中定义的接口，需要实现ServeHTTP方法，按我的理解就是ListenAndServe是用来监听指定端口并且指定对应的处理器，（我的博客里会有很多自己的臆测，请自行判断，也欢迎大佬斧正）如果第二个参数是nil则会调用默认的，去看HandleFunc函数</p><p>那接下来就看一看HandleFunc函数，先上源码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http  </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the URL path prefix.  </span></span><br><span class="line"><span class="comment">// The handler will be called for all requests whose URL path starts with  </span></span><br><span class="line"><span class="comment">// the given prefix.  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;  </span><br><span class="line">    <span class="comment">// Wrap the handler function to convert it to the Handler interface  </span></span><br><span class="line">    Handle(pattern, HandlerFunc(handler))  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc is an adapter to allow the use of ordinary functions as HTTP handlers.  </span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls h(w, r).  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;  </span><br><span class="line">    h(w, r)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle registers the handler h for the given pattern in the DefaultServeMux.  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="type">string</span>, handler Handler)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// Check for nil handler  </span></span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Register the handler in the DefaultServeMux  </span></span><br><span class="line">    DefaultServeMux.Handle(pattern, handler)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler is an interface that wraps the ServeHTTP method.  </span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;  </span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>HandleFunc函数就是将URL路由映射到对应的处理方法，处理方法要实现Handler（处理者）接口（这也是很自然的吧）</p><p>总结一下，ListenAndServe监听，HandleFunc映射路由，Handler处理。</p><h3 id="base2"><a href="#base2" class="headerlink" title="base2"></a>base2</h3><p>上面的base1只是最基本最基本的实现方法，base2主要是要创建一个实例，并且实现Handler接口，放在ListenAndServe函数中的第二个参数的位置上</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// day1-http-base/base2/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine is the uni handler for all requests</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/hello&quot;</span>:</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine := <span class="built_in">new</span>(Engine)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, engine))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义Engine结构体，实现ServeHTTP方法，实现的方式是完全自定义的，也就是说，这里有着更大的开发空间，相当于重构了HandleFunc函数。我们利用engine拦截所有的HTTP请求，然后自定义相应方式，包括路由的对应关系也是，对于之前的HandleFunc函数，只能实现具体的路由与处理方法的一一映射，也就是静态路由，而自定义的话就可以实现动态路由，动态路由简单来说就是实现模糊匹配，一个通式路由可以匹配一系列路由。</p><h3 id="base3"><a href="#base3" class="headerlink" title="base3"></a>base3</h3><p>到base3就初具框架雏形了，base3将构建的东西封装起来，封成一个独立的包，开发者只需调用包中的函数简化开发</p><p>由于代码有点开始多了，在放在这里会比较占篇幅，我不放在这了，想看源码可以移步至教程原文，链接在开头</p><p>以下是基本框架</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gee/</span><br><span class="line">  |--gee.<span class="keyword">go</span></span><br><span class="line">  |--<span class="keyword">go</span>.mod</span><br><span class="line">main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span>.mod</span><br></pre></td></tr></table></figure><p>Engine中多了一个路由匹配表router的东西，顾名思义，将路由映射到处理方法，这与之前的有什么不同呢？这里增加了GET、POST的概念，也就是说，路由并不是原始的url，而是增加了方法method（大概是GET-&#x2F;hello这样的感觉），这将请求进行了分类，扩大了请求的概念范围，同时可以实现在同一个页面发送不同的请求的效果</p><p>总结一下，Engine结构体，内部有路由匹配表，增强了Handler的功能</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客日志（2）</title>
      <link href="/2024/09/18/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89/"/>
      <url>/2024/09/18/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客的报错和解决"><a href="#本博客的报错和解决" class="headerlink" title="本博客的报错和解决"></a>本博客的报错和解决</h1><p>在使用博客的过程中， 也出现了不少问题，虽然在日志（1）中也写了两个报错，而在这里就写写出现的报错我感觉可以单独写一篇，在写这篇博客的时候我可能还没有解决这些错误，会有我的探索过程</p><p>目前出现的最大的问题就是在博客本地仓库修改过之后，进行提交会报错，这种错误我之前也遇到过，一般都是通过推倒重来，重新搭建博客解决的，但这终究不是长久之计，于是想着深入了解报错的原因</p><p>首先我打算查看一下本地仓库和远程仓库的提交记录，看两者出了什么差错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看本地提交记录</span><br><span class="line">git log</span><br><span class="line">//查看远程仓库提交记录</span><br><span class="line">git log origin/main</span><br></pre></td></tr></table></figure><p>看了两边的提交记录之后确实差得很大，甚至就没有重合的部分，可能是我之前由于某种原因清除了本地的原因，既然完全不同，那还是重建仓库好了，这边也是，由于.deploy_git文件夹是用于存储文件以及git提交的文件夹，我本来想过删除本地的提交记录，但是好像不可行，于是我就干脆删除该文件夹，重新放入初始的.deploy_git文件夹，使用hexo g在.deploy_git文件夹中重新生成文件，推送，就好了。</p><p>总结一下，两边进程不同步，初始化.deploy_git文件夹即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树迭代遍历</title>
      <link href="/2024/09/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/09/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树迭代遍历"><a href="#二叉树迭代遍历" class="headerlink" title="二叉树迭代遍历"></a>二叉树迭代遍历</h2><p>本文参考：<a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p>二叉树的遍历使用递归是相当简单优雅的，但如何使用迭代实现？</p><p>对于二叉树的遍历，我将它想象成对一个二叉树结构洞穴的探索，冒险者就是实时锚点cur，而栈则是冒险者经过某些路口在地图上标记的信息</p><p>前序遍历（中左右）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先将根节点放入栈中，然后拿出，之后放入右左，由于后进先出，拿出来顺序就是左右，总的来说是这么个逻辑。那么每次都会将栈的最外面的元素作为cur，也就是目前的锚点，新元素的加入需要依靠这个锚点，也就是实时的《中》。在遍历的过程中，我们就将这个实时的锚点输出，也根据这个锚点更深一步探索这棵二叉树</p><p>中序遍历（左中右）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归算法可以通过简单地交换顺序实现前序和中序的转化，但是迭代就不行，究其原因是因为，对于前序遍历来说，搜索顺序和输出顺序是一样的，也就是实时的锚点也可以实时输出，而中序遍历不同，要实现左中右的顺序，首先我们需要找到那个最左的元素，而且我们需要记住一路上的节点，也就是要存到栈里，方便我们回找。想要中序遍历我们的策略就是尽可能地往左拐，走到死胡同就回来右拐一下，然后继续一直死命左拐</p><p>后序遍历（左右中）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历倒是可以由前序遍历稍加修改变换而成，先将中左右改成中右左，然后取反，就成了左右中，这一手还是很巧妙的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客日志（1）</title>
      <link href="/2024/09/03/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/"/>
      <url>/2024/09/03/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客的搭建方法"><a href="#本博客的搭建方法" class="headerlink" title="本博客的搭建方法"></a>本博客的搭建方法</h1><p>省流：Hexo框架 + Butterfly主题搭建博客</p><p>搭建方法主要参考：</p><p><a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p><p><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/">https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化Hexo</span><br><span class="line">hexo init MyBlog</span><br><span class="line"></span><br><span class="line">@_config.yml配置文件</span><br><span class="line">//修改基本信息，部署网址位置，这里我选择部署到github pages上（因为免费x</span><br><span class="line"></span><br><span class="line">//安装hexo框架中的git部署</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">*至此可以在公网上部署博客了，虽然是最基本的格式</span><br><span class="line"></span><br><span class="line">//安装butterfly主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">//安装渲染器插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br><span class="line">*至此可以实现butterfly主题的博客</span><br></pre></td></tr></table></figure><p>报错1：</p><p><img src="/./img/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/image-20240830140436370.png" alt="image-20240830140436370"></p><p>虽然只是个警告，但是这个警告表示找不到页面，到时候会打不开页面的，导致报错的原因是在主配置文件中将主题改成了butterfly（theme: butterfly），但是在theme文件夹里没有butterfly的原因</p><p>报错2：</p><p><img src="/./img/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/image-20240830142055295.png" alt="image-20240830142055295"></p><p>出现这个错误的原因只是因为没有安装渲染器插件，所以无法渲染页面而已（废话x</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About My Blog</title>
      <link href="/2024/09/03/About_My_Blog/"/>
      <url>/2024/09/03/About_My_Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="About-My-Blog"><a href="#About-My-Blog" class="headerlink" title="About My Blog"></a>About My Blog</h1><p>前言：在搭建这个博客的时候我已经快大二了，大学时光所剩不多，搭建这个博客除了作为存放学习笔记的地方，也是我告别迷茫大一开启新篇章的里程碑，希望未来的我能够大展拳脚，拥有一段精彩的大学生活。</p><p>​——致    未来的Youndry</p><p>由于本人的学习方法，本博客并不会事无巨细地整理记录，那样过于低效，本博客只是大概地记录学习过程中的关键过程，或者写一写自己的感悟。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/27/hello-world/"/>
      <url>/2024/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
