<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo博客日志（2）</title>
      <link href="/2024/09/18/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89/"/>
      <url>/2024/09/18/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客的报错和解决"><a href="#本博客的报错和解决" class="headerlink" title="本博客的报错和解决"></a>本博客的报错和解决</h1><p>在使用博客的过程中， 也出现了不少问题，虽然在日志（1）中也写了两个报错，而在这里就写写出现的报错我感觉可以单独写一篇，在写这篇博客的时候我可能还没有解决这些错误，会有我的探索过程</p><p>目前出现的最大的问题就是在博客本地仓库修改过之后，进行提交会报错，这种错误我之前也遇到过，一般都是通过推倒重来，重新搭建博客解决的，但这终究不是长久之计，于是想着深入了解报错的原因</p><p>首先我打算查看一下本地仓库和远程仓库的提交记录，看两者出了什么差错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看本地提交记录</span><br><span class="line">git log</span><br><span class="line">//查看远程仓库提交记录</span><br><span class="line">git log origin/main</span><br></pre></td></tr></table></figure><p>看了两边的提交记录之后确实差得很大，甚至就没有重合的部分，可能是我之前由于某种原因清除了本地的原因，既然完全不同，那还是重建仓库好了，这边也是，由于.deploy_git文件夹是用于存储文件以及git提交的文件夹，我本来想过删除本地的提交记录，但是好像不可行，于是我就干脆删除该文件夹，重新放入初始的.deploy_git文件夹，使用hexo g在.deploy_git文件夹中重新生成文件，推送，就好了。</p><p>总结一下，两边进程不同步，初始化.deploy_git文件夹即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树迭代遍历</title>
      <link href="/2024/09/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/09/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树迭代遍历"><a href="#二叉树迭代遍历" class="headerlink" title="二叉树迭代遍历"></a>二叉树迭代遍历</h2><p>本文参考：<a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p>二叉树的遍历使用递归是相当简单优雅的，但如何使用迭代实现？</p><p>对于二叉树的遍历，我将它想象成对一个二叉树结构洞穴的探索，冒险者就是实时锚点cur，而栈则是冒险者经过某些路口在地图上标记的信息</p><p>前序遍历（中左右）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先将根节点放入栈中，然后拿出，之后放入右左，由于后进先出，拿出来顺序就是左右，总的来说是这么个逻辑。那么每次都会将栈的最外面的元素作为cur，也就是目前的锚点，新元素的加入需要依靠这个锚点，也就是实时的《中》。在遍历的过程中，我们就将这个实时的锚点输出，也根据这个锚点更深一步探索这棵二叉树</p><p>中序遍历（左中右）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归算法可以通过简单地交换顺序实现前序和中序的转化，但是迭代就不行，究其原因是因为，对于前序遍历来说，搜索顺序和输出顺序是一样的，也就是实时的锚点也可以实时输出，而中序遍历不同，要实现左中右的顺序，首先我们需要找到那个最左的元素，而且我们需要记住一路上的节点，也就是要存到栈里，方便我们回找。想要中序遍历我们的策略就是尽可能地往左拐，走到死胡同就回来右拐一下，然后继续一直死命左拐</p><p>后序遍历（左右中）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历倒是可以由前序遍历稍加修改变换而成，先将中左右改成中右左，然后取反，就成了左右中，这一手还是很巧妙的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客日志（1）</title>
      <link href="/2024/09/03/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/"/>
      <url>/2024/09/03/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="本博客的搭建方法"><a href="#本博客的搭建方法" class="headerlink" title="本博客的搭建方法"></a>本博客的搭建方法</h1><p>省流：Hexo框架 + Butterfly主题搭建博客</p><p>搭建方法主要参考：</p><p><a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p><p><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/">https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化Hexo</span><br><span class="line">hexo init MyBlog</span><br><span class="line"></span><br><span class="line">@_config.yml配置文件</span><br><span class="line">//修改基本信息，部署网址位置，这里我选择部署到github pages上（因为免费x</span><br><span class="line"></span><br><span class="line">//安装hexo框架中的git部署</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">*至此可以在公网上部署博客了，虽然是最基本的格式</span><br><span class="line"></span><br><span class="line">//安装butterfly主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">//安装渲染器插件</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br><span class="line">*至此可以实现butterfly主题的博客</span><br></pre></td></tr></table></figure><p>报错1：</p><p><img src="/./img/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/image-20240830140436370.png" alt="image-20240830140436370"></p><p>虽然只是个警告，但是这个警告表示找不到页面，到时候会打不开页面的，导致报错的原因是在主配置文件中将主题改成了butterfly（theme: butterfly），但是在theme文件夹里没有butterfly的原因</p><p>报错2：</p><p><img src="/./img/Hexo%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97%EF%BC%881%EF%BC%89.assets/image-20240830142055295.png" alt="image-20240830142055295"></p><p>出现这个错误的原因只是因为没有安装渲染器插件，所以无法渲染页面而已（废话x</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About My Blog</title>
      <link href="/2024/09/03/About_My_Blog/"/>
      <url>/2024/09/03/About_My_Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="About-My-Blog"><a href="#About-My-Blog" class="headerlink" title="About My Blog"></a>About My Blog</h1><p>前言：在搭建这个博客的时候我已经快大二了，大学时光所剩不多，搭建这个博客除了作为存放学习笔记的地方，也是我告别迷茫大一开启新篇章的里程碑，希望未来的我能够大展拳脚，拥有一段精彩的大学生活。</p><p>​——致    未来的Youndry</p><p>由于本人的学习方法，本博客并不会事无巨细地整理记录，那样过于低效，本博客只是大概地记录学习过程中的关键过程，或者写一写自己的感悟。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/27/hello-world/"/>
      <url>/2024/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
